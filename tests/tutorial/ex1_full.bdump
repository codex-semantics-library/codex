Entering directory '/home/julien/Repos58/codex'
Leaving directory '/home/julien/Repos58/codex'
[codex:result] [0x00000000]
               Region: address 34 filesize 160 filesize_mul_4 160 memsize 160
[codex:result] [0x00000000]
               Region: address 194 filesize 13 filesize_mul_4 10 memsize 13
[codex:result] [0x00000000]
               Region: address 0 filesize 3d4 filesize_mul_4 3d4 memsize 3d4
[codex:result] [0x00000000]
               Region: address 1000 filesize 2c4 filesize_mul_4 2c4 memsize 2c4
[codex:result] [0x00000000]
               Region: address 2000 filesize 114 filesize_mul_4 114 memsize 114
[codex:result] [0x00000000]
               Region: address 3ed8 filesize 130 filesize_mul_4 130 memsize 134
[codex:result] [0x00000000]
               Region: address 3ee0 filesize f8 filesize_mul_4 f8 memsize f8
[codex:result] [0x00000000]
               Region: address 1a8 filesize 44 filesize_mul_4 44 memsize 44
[codex:result] [0x00000000]
               Region: address 2008 filesize 3c filesize_mul_4 3c memsize 3c
[codex:result] [0x00000000]
               Region: address 0 filesize 0 filesize_mul_4 0 memsize 0
[codex:result] [0x00000000]
               Region: address 3ed8 filesize 128 filesize_mul_4 128 memsize 128
[codex:result] [0x00000000] *** End of memory initialization. ***
[codex:result] [0x00000000] -check- load_param_nonptr_old
[codex:result] [0x00000000] ##### Iteration 0 #####
[codex:result] [0x00000000]  0x0000119d

[codex:result] [0x00000000] 1 expressions computed!

[codex:result] [0x00000000] Analyze end node 0x0000119d.
[codex:result] [0x0000119d] instruction cache miss
[codex:result] [0x0000119d] count: 1 address: 0x0000119d
               instruction: push ebp
               block:  0: @[(esp<32> - 4<32>),4] := ebp<32>;
                       1: esp<32> := (esp<32> - 4<32>);
                       2: goto (0x0000119e, 0) 
                      
[codex:result] [0x0000119d] edge from 0 to 1
[codex:result] [0x0000119d] -check- ptr_arith
[codex:result] [0x0000119d] edge from 1 to 2
[codex:result] [0x0000119d] -check- ptr_arith
[codex:result] [0x0000119d] Changes after dhunk: esp -> {0xFFFC}

[codex:result] [0x0000119e] next, case vertex new
[codex:result] [0x0000119e] adding tree edge 0x0000119d -> 0x0000119e
[codex:result] [0x0000119e] end next, case vertex new
[codex:result] [0x0000119e] instruction cache miss
[codex:result] [0x0000119e] count: 2 address: 0x0000119e
               instruction: mov ebp, esp
               block:  0: ebp<32> := esp<32>;
                       1: goto (0x000011a0, 0) 
                      
[codex:result] [0x0000119e] edge from 0 to 1
[codex:result] [0x0000119e] Changes after dhunk: ebp -> {0xFFFC}

[codex:result] [0x000011a0] next, case vertex new
[codex:result] [0x000011a0] adding tree edge 0x0000119e -> 0x000011a0
[codex:result] [0x000011a0] end next, case vertex new
[codex:result] [0x000011a0] instruction cache miss
[codex:result] [0x000011a0] count: 3 address: 0x000011a0
               instruction: sub esp, 0x10
               block:  0: res32<32> := (esp<32> - 16<32>);
                       1: OF<1> :=
                           (esp<32>{31} & (esp<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> := (esp<32>{0,3} <u 0<4>);
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (esp<32> <u 16<32>);
                       7: esp<32> := res32<32>;
                       8: goto (0x000011a3, 0) 
                      
[codex:result] [0x000011a0] edge from 0 to 1
[codex:result] [0x000011a0] -check- ptr_arith
[codex:result] [0x000011a0] edge from 1 to 2
[codex:result] [0x000011a0] edge from 2 to 3
[codex:result] [0x000011a0] edge from 3 to 4
[codex:result] [0x000011a0] edge from 4 to 5
[codex:result] [0x000011a0] edge from 5 to 6
[codex:result] [0x000011a0] edge from 6 to 7
[codex:result] [0x000011a0] edge from 7 to 8
[codex:result] [0x000011a0]
               Changes after dhunk: esp -> {0xFFEC}
CF -> {0}
PF -> {0}
AF -> {0}
ZF -> {0}
SF -> {0}
OF -> {0}
res32 -> {0xFFEC}

[codex:result] [0x000011a3] next, case vertex new
[codex:result] [0x000011a3] adding tree edge 0x000011a0 -> 0x000011a3
[codex:result] [0x000011a3] end next, case vertex new
[codex:result] [0x000011a3] instruction cache miss
[codex:result] [0x000011a3] count: 4 address: 0x000011a3
               instruction: call 0x12a8
               block:  0: esp<32> := (esp<32> - 4<32>);
                       1: @[esp<32>,4] := 0x000011a8;
                       2: goto (0x000012a8, 0) #call with return address @ (0x000011a8, 0)
                      
[codex:result] [0x000011a3] edge from 0 to 1
[codex:result] [0x000011a3] -check- ptr_arith
[codex:result] [0x000011a3] edge from 1 to 2
[codex:result] [0x000011a3] Changes after dhunk: esp -> {0xFFE8}

[codex:result] [0x000012a8] next, case vertex new
[codex:result] [0x000012a8]
               adding tree edge 0x000011a3 -> 0x000012a8_0x000011a3
[codex:result] [0x000012a8]
               Calling function __x86.get_pc_thunk.ax from zeros_buffer
[codex:result] [0x000012a8] end next, case vertex new
[codex:result] [0x000012a8] instruction cache miss
[codex:result] [0x000012a8] count: 5 address: 0x000012a8
               instruction: mov eax, [esp]
               block:  0: eax<32> := @[esp<32>,4];
                       1: goto (0x000012ab, 0) 
                      
[codex:result] [0x000012a8] edge from 0 to 1
[codex:result] [0x000012a8] -check- array_offset_access
[codex:result] [0x000012a8] Changes after dhunk: eax -> {4520}

[codex:result] [0x000012ab] next, case vertex new
[codex:result] [0x000012ab]
               adding tree edge 0x000012a8_0x000011a3 -> 0x000012ab_0x000011a3
[codex:result] [0x000012ab] end next, case vertex new
[codex:result] [0x000012ab] instruction cache miss
[codex:result] [0x000012ab] count: 6 address: 0x000012ab
               instruction: ret
               block:  0: esp<32> := (esp<32> + 4<32>);
                       1: goto @[(esp<32> - 4<32>),4] #return
                      
[codex:result] [0x000012ab] edge from 0 to 1
[codex:result] [0x000012ab] -check- ptr_arith
[codex:result] [0x000012ab] -check- ptr_arith
[codex:result] [0x000012ab] -check- array_offset_access
[codex:result] [0x000012ab] -check- unresolved_dynamic_jump
[codex:result] [0x000012ab] Changes after dhunk: esp -> {0xFFEC}

[codex:result] [0x000011a8] next, case vertex new
[codex:result] [0x000011a8]
               adding tree edge 0x000012ab_0x000011a3 -> 0x000011a8
[codex:result] [0x000011a8]
               Returning from function __x86.get_pc_thunk.ax into zeros_buffer
[codex:result] [0x000011a8] end next, case vertex new
[codex:result] [0x000011a8] instruction cache miss
[codex:result] [0x000011a8] count: 7 address: 0x000011a8
               instruction: add eax, 0x2e30
               block:  0: res32<32> := (eax<32> + 0x00002e30);
                       1: OF<1> :=
                           (! (eax<32>{31}) & (eax<32>{31} <> res32<32>{31}))
                           ;
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> := 0<1>;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) +
                            0b000000000000000000010111000110000){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011ad, 0) 
                      
[codex:result] [0x000011a8] edge from 0 to 1
[codex:result] [0x000011a8] -check- ptr_arith
[codex:result] [0x000011a8] edge from 1 to 2
[codex:result] [0x000011a8] edge from 2 to 3
[codex:result] [0x000011a8] edge from 3 to 4
[codex:result] [0x000011a8] edge from 4 to 5
[codex:result] [0x000011a8] edge from 5 to 6
[codex:result] [0x000011a8] edge from 6 to 7
[codex:result] [0x000011a8] -check- ptr_arith
[codex:result] [0x000011a8] edge from 7 to 8
[codex:result] [0x000011a8]
               Changes after dhunk: eax -> {0x3FD8}
CF -> {0}
PF -> {-1}
AF -> {0x0}
res32 -> {0x3FD8}

[codex:result] [0x000011ad] next, case vertex new
[codex:result] [0x000011ad] adding tree edge 0x000011a8 -> 0x000011ad
[codex:result] [0x000011ad] end next, case vertex new
[codex:result] [0x000011ad] instruction cache miss
[codex:result] [0x000011ad] count: 8 address: 0x000011ad
               instruction: mov eax, [ebp + 0x8]
               block:  0: eax<32> := @[(ebp<32> + 8<32>),4];
                       1: goto (0x000011b0, 0) 
                      
[codex:result] [0x000011ad] edge from 0 to 1
[codex:result] [0x000011ad] -check- ptr_arith
[codex:result] [0x000011ad] -check- array_offset_access
[codex:result] [0x000011ad]
               Changes after dhunk: eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message_box))[{0}].0*)

[codex:result] [0x000011b0] next, case vertex new
[codex:result] [0x000011b0] adding tree edge 0x000011ad -> 0x000011b0
[codex:result] [0x000011b0] end next, case vertex new
[codex:result] [0x000011b0] instruction cache miss
[codex:result] [0x000011b0] count: 9 address: 0x000011b0
               instruction: mov eax, [eax + 0x4]
               block:  0: eax<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011b3, 0) 
                      
[codex:result] [0x000011b0] edge from 0 to 1
[codex:result] [0x000011b0] -check- ptr_arith
[1;31m[codex:error] [0x000011b0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011b0] -check- array_offset_access
[codex:result] [0x000011b0] -check- load_param_nonptr
[codex:result] [0x000011b0] -check- load_param_nonptr_old
[codex:result] [0x000011b0]
               Changes after dhunk: eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011b3] next, case vertex new
[codex:result] [0x000011b3] adding tree edge 0x000011b0 -> 0x000011b3
[codex:result] [0x000011b3] end next, case vertex new
[codex:result] [0x000011b3] instruction cache miss
[codex:result] [0x000011b3] count: 10 address: 0x000011b3
               instruction: mov [ebp + 0xfffffff4], eax
               block:  0: @[(ebp<32> + -12<32>),4] := eax<32>;
                       1: goto (0x000011b6, 0) 
                      
[codex:result] [0x000011b3] edge from 0 to 1
[codex:result] [0x000011b3] -check- ptr_arith
[codex:result] [0x000011b3] Changes after dhunk: 
[codex:result] [0x000011b6] next, case vertex new
[codex:result] [0x000011b6] adding tree edge 0x000011b3 -> 0x000011b6
[codex:result] [0x000011b6] end next, case vertex new
[codex:result] [0x000011b6] instruction cache miss
[codex:result] [0x000011b6] count: 11 address: 0x000011b6
               instruction: mov eax, [ebp + 0xfffffff4]
               block:  0: eax<32> := @[(ebp<32> + -12<32>),4];
                       1: goto (0x000011b9, 0) 
                      
[codex:result] [0x000011b6] edge from 0 to 1
[codex:result] [0x000011b6] -check- ptr_arith
[codex:result] [0x000011b6] -check- array_offset_access
[codex:result] [0x000011b6] Changes after dhunk: 
[codex:result] [0x000011b9] next, case vertex new
[codex:result] [0x000011b9] adding tree edge 0x000011b6 -> 0x000011b9
[codex:result] [0x000011b9] end next, case vertex new
[codex:result] [0x000011b9] instruction cache miss
[codex:result] [0x000011b9] count: 12 address: 0x000011b9
               instruction: mov [ebp + 0xfffffffc], eax
               block:  0: @[(ebp<32> + -4<32>),4] := eax<32>;
                       1: goto (0x000011bc, 0) 
                      
[codex:result] [0x000011b9] edge from 0 to 1
[codex:result] [0x000011b9] -check- ptr_arith
[codex:result] [0x000011b9] Changes after dhunk: 
[codex:result] [0x000011bc] next, case vertex new
[codex:result] [0x000011bc] adding tree edge 0x000011b9 -> 0x000011bc
[codex:result] [0x000011bc] end next, case vertex new
[codex:result] [0x000011bc] instruction cache miss
[codex:result] [0x000011bc] count: 13 address: 0x000011bc
               instruction: mov eax, [ebp + 0x8]
               block:  0: eax<32> := @[(ebp<32> + 8<32>),4];
                       1: goto (0x000011bf, 0) 
                      
[codex:result] [0x000011bc] edge from 0 to 1
[codex:result] [0x000011bc] -check- ptr_arith
[codex:result] [0x000011bc] -check- array_offset_access
[codex:result] [0x000011bc]
               Changes after dhunk: eax -> ([1..0xFFFFFFFF] : (Name(struct message_box))[{0}].0*)

[codex:result] [0x000011bf] next, case vertex new
[codex:result] [0x000011bf] adding tree edge 0x000011bc -> 0x000011bf
[codex:result] [0x000011bf] end next, case vertex new
[codex:result] [0x000011bf] instruction cache miss
[codex:result] [0x000011bf] count: 14 address: 0x000011bf
               instruction: mov eax, [eax]
               block:  0: eax<32> := @[eax<32>,4];
                       1: goto (0x000011c1, 0) 
                      
[codex:result] [0x000011bf] edge from 0 to 1
[codex:result] [0x000011bf] -check- array_offset_access
[codex:result] [0x000011bf] Changes after dhunk: eax -> [--..--]

[codex:result] [0x000011c1] next, case vertex new
[codex:result] [0x000011c1] adding tree edge 0x000011bf -> 0x000011c1
[codex:result] [0x000011c1] end next, case vertex new
[codex:result] [0x000011c1] instruction cache miss
[codex:result] [0x000011c1] count: 15 address: 0x000011c1
               instruction: mov [ebp + 0xfffffff0], eax
               block:  0: @[(ebp<32> + -16<32>),4] := eax<32>;
                       1: goto (0x000011c4, 0) 
                      
[codex:result] [0x000011c1] edge from 0 to 1
[codex:result] [0x000011c1] -check- ptr_arith
[codex:result] [0x000011c1] Changes after dhunk: 
[codex:result] [0x000011c4] next, case vertex new
[codex:result] [0x000011c4] adding tree edge 0x000011c1 -> 0x000011c4
[codex:result] [0x000011c4] end next, case vertex new
[codex:result] [0x000011c4] instruction cache miss
[codex:result] [0x000011c4] count: 16 address: 0x000011c4
               instruction: mov [ebp + 0xfffffff8], 0x0
               block:  0: @[(ebp<32> + -8<32>),4] := 0<32>;
                       1: goto (0x000011cb, 0) 
                      
[codex:result] [0x000011c4] edge from 0 to 1
[codex:result] [0x000011c4] -check- ptr_arith
[codex:result] [0x000011c4] Changes after dhunk: 
[codex:result] [0x000011cb] next, case vertex new
[codex:result] [0x000011cb] adding tree edge 0x000011c4 -> 0x000011cb
[codex:result] [0x000011cb] end next, case vertex new
[codex:result] [0x000011cb] instruction cache miss
[codex:result] [0x000011cb] count: 17 address: 0x000011cb
               instruction: jmp 0x11df
               block:  0: goto (0x000011df, 0) 
                      
[codex:result] [0x000011cb] Changes after dhunk: 
[codex:result] [0x000011df] next, case vertex new
[codex:result] [0x000011df] adding tree edge 0x000011cb -> 0x000011df
[codex:result] [0x000011df] end next, case vertex new
[codex:result] [0x000011df] instruction cache miss
[codex:result] [0x000011df] count: 18 address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               block:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df] Changes after dhunk: eax -> {0}

[codex:result] [0x000011e2] next, case vertex new
[codex:result] [0x000011e2] adding tree edge 0x000011df -> 0x000011e2
[codex:result] [0x000011e2] end next, case vertex new
[codex:result] [0x000011e2] instruction cache miss
[codex:result] [0x000011e2] count: 19 address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               block:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[Single_value_abstraction.Ival_basis] Warning: No backpropagation for 'bextract'
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1037)> new <(b:1041)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1037)> new <(b:1042)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1046)> new <(b:1050)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1046)> new <(b:1051)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1055)> new <(b:1059)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1055)> new <(b:1060)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1073)> new <(b:1077)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1073)> new <(b:1078)>
[codex:result] [0x000011e2] edge from 5 to 6
[Single_value_abstraction.Noop] Warning: No backpropagation for 'bxor'
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1102)> new <(b:1106)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1102)> new <(b:1107)>
[codex:result] [0x000011e2]
               Changes after dhunk: CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e5] next, case vertex new
[codex:result] [0x000011e5] adding tree edge 0x000011e2 -> 0x000011e5
[codex:result] [0x000011e5] end next, case vertex new
[codex:result] [0x000011e5] instruction cache miss
[codex:result] [0x000011e5] count: 20 address: 0x000011e5
               instruction: jl 0x11cd
               block:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1114)> new <(b:1118)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1114)> new <(b:1119)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1114)> new <(b:1122)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1114)> new <(b:1123)>
[codex:result] [0x000011e5] Warning: forking paths
[codex:result] [0x000011e5] New path 0
[codex:result] [0x000011e5] Changes after dhunk: 
[codex:result] [0x000011e7] next, case vertex new
[codex:result] [0x000011e7] adding tree edge 0x000011e5 -> 0x000011e7
[codex:result] [0x000011e7] end next, case vertex new
[codex:result] [0x000011e7] instruction cache miss
[codex:result] [0x000011e7] count: 21 address: 0x000011e7
               instruction: mov eax, [ebp + 0xfffffffc]
               block:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011ea, 0) 
                      
[codex:result] [0x000011e7] edge from 0 to 1
[codex:result] [0x000011e7] -check- ptr_arith
[codex:result] [0x000011e7] -check- array_offset_access
[codex:result] [0x000011e7]
               Changes after dhunk: eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011ea] next, case vertex new
[codex:result] [0x000011ea] adding tree edge 0x000011e7 -> 0x000011ea
[codex:result] [0x000011ea] end next, case vertex new
[codex:result] [0x000011ea] instruction cache miss
[codex:result] [0x000011ea] count: 22 address: 0x000011ea
               instruction: mov eax, [eax]
               block:  0: eax<32> := @[eax<32>,4];
                       1: goto (0x000011ec, 0) 
                      
[codex:result] [0x000011ea] edge from 0 to 1
[codex:result] [0x000011ea] -check- array_offset_access
[1;31m[codex:error] [0x000011ea] -alarm- -alarm- invalid_load_access[0m[0m
[codex:result] [0x000011ea] -check- load_param_nonptr
[codex:result] [0x000011ea] -check- load_param_nonptr_old
[codex:result] [0x000011ea] -check- load_param_nonptr_old
[codex:result] [0x000011ea]
               Changes after dhunk: eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011ec] next, case vertex new
[codex:result] [0x000011ec] adding tree edge 0x000011ea -> 0x000011ec
[codex:result] [0x000011ec] end next, case vertex new
[codex:result] [0x000011ec] instruction cache miss
[codex:result] [0x000011ec] count: 23 address: 0x000011ec
               instruction: mov [ebp + 0xfffffffc], eax
               block:  0: @[(ebp<32> + -4<32>),4] := eax<32>;
                       1: goto (0x000011ef, 0) 
                      
[codex:result] [0x000011ec] edge from 0 to 1
[codex:result] [0x000011ec] -check- ptr_arith
[codex:result] [0x000011ec] Changes after dhunk: 
[codex:result] [0x000011ef] next, case vertex new
[codex:result] [0x000011ef] adding tree edge 0x000011ec -> 0x000011ef
[codex:result] [0x000011ef] end next, case vertex new
[codex:result] [0x000011ef] instruction cache miss
[codex:result] [0x000011ef] count: 24 address: 0x000011ef
               instruction: mov eax, [ebp + 0xfffffffc]
               block:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011f2, 0) 
                      
[codex:result] [0x000011ef] edge from 0 to 1
[codex:result] [0x000011ef] -check- ptr_arith
[codex:result] [0x000011ef] -check- array_offset_access
[codex:result] [0x000011ef] Changes after dhunk: 
[codex:result] [0x000011f2] next, case vertex new
[codex:result] [0x000011f2] adding tree edge 0x000011ef -> 0x000011f2
[codex:result] [0x000011f2] end next, case vertex new
[codex:result] [0x000011f2] instruction cache miss
[codex:result] [0x000011f2] count: 25 address: 0x000011f2
               instruction: cmp eax, [ebp + 0xfffffff4]
               block:  0: res32<32> := (eax<32> - @[(ebp<32> + -12<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -9<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -12<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -12<32>),4]);
                       7: goto (0x000011f5, 0) 
                      
[codex:result] [0x000011f2] edge from 0 to 1
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2] -check- ptr_arith
[1;31m[codex:error] [0x000011f2] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011f2] edge from 1 to 2
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:1156)> new <(b:1160)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:1156)> new <(b:1161)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:1165)> new <(b:1169)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:1165)> new <(b:1170)>
[codex:result] [0x000011f2] edge from 2 to 3
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:1174)> new <(b:1178)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:1174)> new <(b:1179)>
[codex:result] [0x000011f2] edge from 3 to 4
[codex:result] [0x000011f2] edge from 4 to 5
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:1192)> new <(b:1196)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:1192)> new <(b:1197)>
[codex:result] [0x000011f2] edge from 5 to 6
[codex:result] [0x000011f2] edge from 6 to 7
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:1221)> new <(b:1225)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:1221)> new <(b:1226)>
[codex:result] [0x000011f2]
               Changes after dhunk: CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011f5] next, case vertex new
[codex:result] [0x000011f5] adding tree edge 0x000011f2 -> 0x000011f5
[codex:result] [0x000011f5] end next, case vertex new
[codex:result] [0x000011f5] instruction cache miss
[codex:result] [0x000011f5] count: 26 address: 0x000011f5
               instruction: jnz 0x11c4
               block:  0: if ! (ZF<1>) goto (0x000011c4, 0) else goto 1
                       1: goto (0x000011f7, 0) 
                      
[codex:result] [0x000011f5] edge from 0 to 1
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:1182)> new <(b:1229)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:1182)> new <(b:1230)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:1182)> new <(b:1233)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:1182)> new <(b:1234)>
[codex:result] [0x000011f5] Warning: forking paths
[codex:result] [0x000011f5] New path 0
[codex:result] [0x000011f5] Changes after dhunk: 
[codex:result] [0x000011f7] next, case vertex new
[codex:result] [0x000011f7] adding tree edge 0x000011f5 -> 0x000011f7
[codex:result] [0x000011f7] end next, case vertex new
[codex:result] [0x000011f7] instruction cache miss
[codex:result] [0x000011f7] count: 27 address: 0x000011f7
               instruction: nop
               block:  0: goto (0x000011f8, 0) 
                      
[codex:result] [0x000011f7] Changes after dhunk: 
[codex:result] [0x000011f8] next, case vertex new
[codex:result] [0x000011f8] adding tree edge 0x000011f7 -> 0x000011f8
[codex:result] [0x000011f8] end next, case vertex new
[codex:result] [0x000011f8] instruction cache miss
[codex:result] [0x000011f8] count: 28 address: 0x000011f8
               instruction: nop
               block:  0: goto (0x000011f9, 0) 
                      
[codex:result] [0x000011f8] Changes after dhunk: 
[codex:result] [0x000011f9] next, case vertex new
[codex:result] [0x000011f9] adding tree edge 0x000011f8 -> 0x000011f9
[codex:result] [0x000011f9] end next, case vertex new
[codex:result] [0x000011f9] instruction cache miss
[codex:result] [0x000011f9] count: 29 address: 0x000011f9
               instruction: leave
               block:  0: esp<32> := ebp<32>;
                       1: ebp<32> := @[esp<32>,4];
                       2: esp<32> := (esp<32> + 4<32>);
                       3: goto (0x000011fa, 0) 
                      
[codex:result] [0x000011f9] edge from 0 to 1
[codex:result] [0x000011f9] edge from 1 to 2
[codex:result] [0x000011f9] -check- array_offset_access
[codex:result] [0x000011f9] edge from 2 to 3
[codex:result] [0x000011f9] -check- ptr_arith
[codex:result] [0x000011f9]
               Changes after dhunk: esp -> {0x10000}
ebp -> [--..--]

[codex:result] [0x000011fa] next, case vertex new
[codex:result] [0x000011fa] adding tree edge 0x000011f9 -> 0x000011fa
[codex:result] [0x000011fa] end next, case vertex new
[codex:result] [0x000011fa] instruction cache miss
[codex:result] [0x000011fa] count: 30 address: 0x000011fa
               instruction: ret
               block:  0: esp<32> := (esp<32> + 4<32>);
                       1: goto @[(esp<32> - 4<32>),4] #return
                      
[codex:result] [0x000011fa] edge from 0 to 1
[codex:result] [0x000011fa] -check- ptr_arith
[codex:result] [0x000011fa] -check- ptr_arith
[codex:result] [0x000011fa] -check- array_offset_access
[codex:result] [0x000011fa] -check- unresolved_dynamic_jump
[codex:result] [0x000011fa] Changes after dhunk: esp -> {0x10004}

[codex:result] [0xfedcba98] next, case vertex new
[codex:result] [0xfedcba98]
               adding tree edge 0x000011fa -> 0xfedcba98_0x000011fa
[codex:result] [0xfedcba98] Calling function _end from zeros_buffer
[codex:result] [0xfedcba98] end next, case vertex new
[1;31m[codex:error] [0xfedcba98] Manual skip at 0xfedcba98![0m[0m
[codex:result] [0xfedcba98] Reaching return instruction. Reason: Return hook
[codex:result] [0xfedcba98] Warning: ending path
[codex:result] [0xfedcba98] Done path 0
[codex:result] [0xfedcba98] New path 1
[codex:result] [0xfedcba98] Changes after dhunk: 
[codex:result] [0x000011c4] next, case vertex existing
[codex:result] [0x000011c4] end next, case vertex existing
[codex:result] [0x000011c4] Visited vertex, ending path.
[codex:result] [0x000011c4] number of forks on the stack: 3
[codex:result] [0x000011c4] Done path 1
[codex:result] [0x000011c4] Done path 0
[codex:result] [0x000011c4] New path 1
[codex:result] [0x000011c4] Changes after dhunk: 
[codex:result] [0x000011cd] next, case vertex new
[codex:result] [0x000011cd] adding tree edge 0x000011e5 -> 0x000011cd
[codex:result] [0x000011cd] end next, case vertex new
[codex:result] [0x000011cd] instruction cache miss
[codex:result] [0x000011cd] count: 21 address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               block:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               Changes after dhunk: eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011d0] next, case vertex new
[codex:result] [0x000011d0] adding tree edge 0x000011cd -> 0x000011d0
[codex:result] [0x000011d0] end next, case vertex new
[codex:result] [0x000011d0] instruction cache miss
[codex:result] [0x000011d0] count: 22 address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               block:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               Changes after dhunk: edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d3] next, case vertex new
[codex:result] [0x000011d3] adding tree edge 0x000011d0 -> 0x000011d3
[codex:result] [0x000011d3] end next, case vertex new
[codex:result] [0x000011d3] instruction cache miss
[codex:result] [0x000011d3] count: 23 address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               block:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3] Changes after dhunk: eax -> {0}

[codex:result] [0x000011d6] next, case vertex new
[codex:result] [0x000011d6] adding tree edge 0x000011d3 -> 0x000011d6
[codex:result] [0x000011d6] end next, case vertex new
[codex:result] [0x000011d6] instruction cache miss
[codex:result] [0x000011d6] count: 24 address: 0x000011d6
               instruction: add eax, edx
               block:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:1258)> new <(b:1264)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:1258)> new <(b:1265)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               Changes after dhunk: eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
CF -> {0}
PF -> Bofbool { [--..--] of size 1 }
AF -> {0}
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d8] next, case vertex new
[codex:result] [0x000011d8] adding tree edge 0x000011d6 -> 0x000011d8
[codex:result] [0x000011d8] end next, case vertex new
[codex:result] [0x000011d8] instruction cache miss
[codex:result] [0x000011d8] count: 25 address: 0x000011d8
               instruction: mov [eax], 0x0
               block:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- load_param_nonptr
[codex:result] [0x000011d8] Changes after dhunk: 
[codex:result] [0x000011db] next, case vertex new
[codex:result] [0x000011db] adding tree edge 0x000011d8 -> 0x000011db
[codex:result] [0x000011db] end next, case vertex new
[codex:result] [0x000011db] instruction cache miss
[codex:result] [0x000011db] count: 26 address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               block:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               Changes after dhunk: CF -> {0}
PF -> {0}
AF -> {0}
SF -> {0}
OF -> {0}
res32 -> {1}

[codex:result] [0x000011df] next, case vertex existing
[codex:result] [0x000011df] end next, case vertex existing
[codex:result] [0x000011df] Visited vertex, ending path.
[codex:result] [0x000011df] number of forks on the stack: 2
[codex:result] [0x000011df] Done path 1
[codex:result] [0x000011df] Fixpoint not reached.
[codex:result] [0x000011df] RecordTrace.close called
[codex:result] [0x000011df] basic_block_graph: 37 nodes
[codex:result] [0x000011df] ##### Iteration 1 #####
[codex:result] [0x000011df]  0x0000119d 0x0000119e 0x000011a0 0x000011a3
               0x000012a8_0x000011a3 0x000012ab_0x000011a3 0x000011a8
               0x000011ad 0x000011b0 0x000011b3 0x000011b6 0x000011b9
               0x000011bc 0x000011bf 0x000011c1
               (0x000011c4 0x000011cb
                (0x000011df 0x000011e2 0x000011e5 0x000011cd 0x000011d0
                 0x000011d3 0x000011d6 0x000011d8 0x000011db) 0x000011e7
                0x000011ea 0x000011ec 0x000011ef 0x000011f2 0x000011f5)
               0x000011f7 0x000011f8 0x000011f9 0x000011fa
               0xfedcba98_0x000011fa

[codex:result] [0x000011df] 37 expressions computed!

[codex:result] [0x0000119d] analyze_regex, case Append, src = 0x0000119d
[codex:result] [0x0000119d]
               address: 0x0000119d
               instruction: push ebp
               dhunk:  0: @[(esp<32> - 4<32>),4] := ebp<32>;
                       1: esp<32> := (esp<32> - 4<32>);
                       2: goto (0x0000119e, 0) 
                      
[codex:result] [0x0000119d] edge from 0 to 1
[codex:result] [0x0000119d] -check- ptr_arith
[codex:result] [0x0000119d] edge from 1 to 2
[codex:result] [0x0000119d] -check- ptr_arith
[codex:result] [0x0000119d]
               changes at entry of successor 0 (0x0000119e)
               esp -> {0xFFFC}

[codex:result] [0x0000119d] debug_log = false
[codex:result] [0x0000119e] analyze_regex, case Append, src = 0x0000119e
[codex:result] [0x0000119e]
               address: 0x0000119e
               instruction: mov ebp, esp
               dhunk:  0: ebp<32> := esp<32>;
                       1: goto (0x000011a0, 0) 
                      
[codex:result] [0x0000119e] edge from 0 to 1
[codex:result] [0x0000119e]
               changes at entry of successor 0 (0x000011a0)
               ebp -> {0xFFFC}

[codex:result] [0x0000119e] debug_log = false
[codex:result] [0x000011a0] analyze_regex, case Append, src = 0x000011a0
[codex:result] [0x000011a0]
               address: 0x000011a0
               instruction: sub esp, 0x10
               dhunk:  0: res32<32> := (esp<32> - 16<32>);
                       1: OF<1> :=
                           (esp<32>{31} & (esp<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> := (esp<32>{0,3} <u 0<4>);
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (esp<32> <u 16<32>);
                       7: esp<32> := res32<32>;
                       8: goto (0x000011a3, 0) 
                      
[codex:result] [0x000011a0] edge from 0 to 1
[codex:result] [0x000011a0] -check- ptr_arith
[codex:result] [0x000011a0] edge from 1 to 2
[codex:result] [0x000011a0] edge from 2 to 3
[codex:result] [0x000011a0] edge from 3 to 4
[codex:result] [0x000011a0] edge from 4 to 5
[codex:result] [0x000011a0] edge from 5 to 6
[codex:result] [0x000011a0] edge from 6 to 7
[codex:result] [0x000011a0] edge from 7 to 8
[codex:result] [0x000011a0]
               changes at entry of successor 0 (0x000011a3)
               esp -> {0xFFEC}
CF -> {0}
PF -> {0}
AF -> {0}
ZF -> {0}
SF -> {0}
OF -> {0}
res32 -> {0xFFEC}

[codex:result] [0x000011a0] debug_log = false
[codex:result] [0x000011a3] analyze_regex, case Append, src = 0x000011a3
[codex:result] [0x000011a3]
               address: 0x000011a3
               instruction: call 0x12a8
               dhunk:  0: esp<32> := (esp<32> - 4<32>);
                       1: @[esp<32>,4] := 0x000011a8;
                       2: goto (0x000012a8, 0) #call with return address @ (0x000011a8, 0)
                      
[codex:result] [0x000011a3] edge from 0 to 1
[codex:result] [0x000011a3] -check- ptr_arith
[codex:result] [0x000011a3] edge from 1 to 2
[codex:result] [0x000011a3]
               changes at entry of successor 0 (0x000012a8)
               esp -> {0xFFE8}

[codex:result] [0x000011a3] debug_log = false
[codex:result] [0x000012a8]
               analyze_regex, case Append, src = 0x000012a8_0x000011a3
[codex:result] [0x000012a8]
               address: 0x000012a8
               instruction: mov eax, [esp]
               dhunk:  0: eax<32> := @[esp<32>,4];
                       1: goto (0x000012ab, 0) 
                      
[codex:result] [0x000012a8] edge from 0 to 1
[codex:result] [0x000012a8] -check- array_offset_access
[codex:result] [0x000012a8]
               changes at entry of successor 0 (0x000012ab)
               eax -> {4520}

[codex:result] [0x000012a8] debug_log = false
[codex:result] [0x000012ab]
               analyze_regex, case Append, src = 0x000012ab_0x000011a3
[codex:result] [0x000012ab]
               address: 0x000012ab
               instruction: ret
               dhunk:  0: esp<32> := (esp<32> + 4<32>);
                       1: goto @[(esp<32> - 4<32>),4] #return
                      
[codex:result] [0x000012ab] edge from 0 to 1
[codex:result] [0x000012ab] -check- ptr_arith
[codex:result] [0x000012ab] -check- ptr_arith
[codex:result] [0x000012ab] -check- array_offset_access
[codex:result] [0x000012ab] -check- unresolved_dynamic_jump
[codex:result] [0x000012ab]
               changes at entry of successor 0 (0x000011a8)
               esp -> {0xFFEC}

[codex:result] [0x000012ab] debug_log = false
[codex:result] [0x000011a8] analyze_regex, case Append, src = 0x000011a8
[codex:result] [0x000011a8]
               address: 0x000011a8
               instruction: add eax, 0x2e30
               dhunk:  0: res32<32> := (eax<32> + 0x00002e30);
                       1: OF<1> :=
                           (! (eax<32>{31}) & (eax<32>{31} <> res32<32>{31}))
                           ;
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> := 0<1>;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) +
                            0b000000000000000000010111000110000){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011ad, 0) 
                      
[codex:result] [0x000011a8] edge from 0 to 1
[codex:result] [0x000011a8] -check- ptr_arith
[codex:result] [0x000011a8] edge from 1 to 2
[codex:result] [0x000011a8] edge from 2 to 3
[codex:result] [0x000011a8] edge from 3 to 4
[codex:result] [0x000011a8] edge from 4 to 5
[codex:result] [0x000011a8] edge from 5 to 6
[codex:result] [0x000011a8] edge from 6 to 7
[codex:result] [0x000011a8] -check- ptr_arith
[codex:result] [0x000011a8] edge from 7 to 8
[codex:result] [0x000011a8]
               changes at entry of successor 0 (0x000011ad)
               eax -> {0x3FD8}
CF -> {0}
PF -> {-1}
AF -> {0x0}
res32 -> {0x3FD8}

[codex:result] [0x000011a8] debug_log = false
[codex:result] [0x000011ad] analyze_regex, case Append, src = 0x000011ad
[codex:result] [0x000011ad]
               address: 0x000011ad
               instruction: mov eax, [ebp + 0x8]
               dhunk:  0: eax<32> := @[(ebp<32> + 8<32>),4];
                       1: goto (0x000011b0, 0) 
                      
[codex:result] [0x000011ad] edge from 0 to 1
[codex:result] [0x000011ad] -check- ptr_arith
[codex:result] [0x000011ad] -check- array_offset_access
[codex:result] [0x000011ad]
               changes at entry of successor 0 (0x000011b0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message_box))[{0}].0*)

[codex:result] [0x000011ad] debug_log = false
[codex:result] [0x000011b0] analyze_regex, case Append, src = 0x000011b0
[codex:result] [0x000011b0]
               address: 0x000011b0
               instruction: mov eax, [eax + 0x4]
               dhunk:  0: eax<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011b3, 0) 
                      
[codex:result] [0x000011b0] edge from 0 to 1
[codex:result] [0x000011b0] -check- ptr_arith
[1;31m[codex:error] [0x000011b0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011b0] -check- array_offset_access
[codex:result] [0x000011b0] -check- load_param_nonptr
[codex:result] [0x000011b0] -check- load_param_nonptr_old
[codex:result] [0x000011b0]
               changes at entry of successor 0 (0x000011b3)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011b0] debug_log = false
[codex:result] [0x000011b3] analyze_regex, case Append, src = 0x000011b3
[codex:result] [0x000011b3]
               address: 0x000011b3
               instruction: mov [ebp + 0xfffffff4], eax
               dhunk:  0: @[(ebp<32> + -12<32>),4] := eax<32>;
                       1: goto (0x000011b6, 0) 
                      
[codex:result] [0x000011b3] edge from 0 to 1
[codex:result] [0x000011b3] -check- ptr_arith
[codex:result] [0x000011b3] changes at entry of successor 0 (0x000011b6)
                            
[codex:result] [0x000011b3] debug_log = false
[codex:result] [0x000011b6] analyze_regex, case Append, src = 0x000011b6
[codex:result] [0x000011b6]
               address: 0x000011b6
               instruction: mov eax, [ebp + 0xfffffff4]
               dhunk:  0: eax<32> := @[(ebp<32> + -12<32>),4];
                       1: goto (0x000011b9, 0) 
                      
[codex:result] [0x000011b6] edge from 0 to 1
[codex:result] [0x000011b6] -check- ptr_arith
[codex:result] [0x000011b6] -check- array_offset_access
[codex:result] [0x000011b6] changes at entry of successor 0 (0x000011b9)
                            
[codex:result] [0x000011b6] debug_log = false
[codex:result] [0x000011b9] analyze_regex, case Append, src = 0x000011b9
[codex:result] [0x000011b9]
               address: 0x000011b9
               instruction: mov [ebp + 0xfffffffc], eax
               dhunk:  0: @[(ebp<32> + -4<32>),4] := eax<32>;
                       1: goto (0x000011bc, 0) 
                      
[codex:result] [0x000011b9] edge from 0 to 1
[codex:result] [0x000011b9] -check- ptr_arith
[codex:result] [0x000011b9] changes at entry of successor 0 (0x000011bc)
                            
[codex:result] [0x000011b9] debug_log = false
[codex:result] [0x000011bc] analyze_regex, case Append, src = 0x000011bc
[codex:result] [0x000011bc]
               address: 0x000011bc
               instruction: mov eax, [ebp + 0x8]
               dhunk:  0: eax<32> := @[(ebp<32> + 8<32>),4];
                       1: goto (0x000011bf, 0) 
                      
[codex:result] [0x000011bc] edge from 0 to 1
[codex:result] [0x000011bc] -check- ptr_arith
[codex:result] [0x000011bc] -check- array_offset_access
[codex:result] [0x000011bc]
               changes at entry of successor 0 (0x000011bf)
               eax -> ([1..0xFFFFFFFF] : (Name(struct message_box))[{0}].0*)

[codex:result] [0x000011bc] debug_log = false
[codex:result] [0x000011bf] analyze_regex, case Append, src = 0x000011bf
[codex:result] [0x000011bf]
               address: 0x000011bf
               instruction: mov eax, [eax]
               dhunk:  0: eax<32> := @[eax<32>,4];
                       1: goto (0x000011c1, 0) 
                      
[codex:result] [0x000011bf] edge from 0 to 1
[codex:result] [0x000011bf] -check- array_offset_access
[codex:result] [0x000011bf]
               changes at entry of successor 0 (0x000011c1)
               eax -> [--..--]

[codex:result] [0x000011bf] debug_log = false
[codex:result] [0x000011c1] analyze_regex, case Append, src = 0x000011c1
[codex:result] [0x000011c1]
               address: 0x000011c1
               instruction: mov [ebp + 0xfffffff0], eax
               dhunk:  0: @[(ebp<32> + -16<32>),4] := eax<32>;
                       1: goto (0x000011c4, 0) 
                      
[codex:result] [0x000011c1] edge from 0 to 1
[codex:result] [0x000011c1] -check- ptr_arith
[codex:result] [0x000011c1] changes at entry of successor 0 (0x000011c4)
                            
[codex:result] [0x000011c1] debug_log = false
[codex:result] [0x000011c1] Analyzing star...
[codex:result] [0x000011c1] Mu iteration 0 ...
[codex:result] [0x000011c4] analyze_regex, case Append, src = 0x000011c4
[codex:result] [0x000011c4]
               address: 0x000011c4
               instruction: mov [ebp + 0xfffffff8], 0x0
               dhunk:  0: @[(ebp<32> + -8<32>),4] := 0<32>;
                       1: goto (0x000011cb, 0) 
                      
[codex:result] [0x000011c4] edge from 0 to 1
[codex:result] [0x000011c4] -check- ptr_arith
[codex:result] [0x000011c4] changes at entry of successor 0 (0x000011cb)
                            
[codex:result] [0x000011c4] debug_log = false
[codex:result] [0x000011cb] analyze_regex, case Append, src = 0x000011cb
[codex:result] [0x000011cb]
               address: 0x000011cb
               instruction: jmp 0x11df
               dhunk:  0: goto (0x000011df, 0) 
                      
[codex:result] [0x000011cb] changes at entry of successor 0 (0x000011df)
                            
[codex:result] [0x000011cb] debug_log = false
[codex:result] [0x000011cb] Analyzing star...
[codex:result] [0x000011cb] Mu iteration 0 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> {0}

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1350)> new <(b:1354)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1350)> new <(b:1355)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1359)> new <(b:1363)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1359)> new <(b:1364)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1368)> new <(b:1372)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1368)> new <(b:1373)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1384)> new <(b:1388)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1384)> new <(b:1389)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1413)> new <(b:1417)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1413)> new <(b:1418)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1425)> new <(b:1429)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1425)> new <(b:1430)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1425)> new <(b:1433)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1425)> new <(b:1434)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> {0}

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:1456)> new <(b:1462)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:1456)> new <(b:1463)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
CF -> {0}
PF -> Bofbool { [--..--] of size 1 }
AF -> {0}
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- load_param_nonptr
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> {0}
PF -> {0}
AF -> {0}
SF -> {0}
OF -> {0}
res32 -> {1}

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--]
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--]
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> {-1}
                   AF -> {0x0}
                   ZF -> {0}
                   SF -> {0}
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> {0}
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> {0x3FD8}
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> {0}
                   AF -> {0}
                   ZF -> {0}
                   SF -> {0}
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> {0}
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> {1}
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = {0x0}, b = {0}
[codex:result] [0x000011db] ### register CF: a = {0}, b = {0}
[codex:result] [0x000011db] ### register OF: a = {0}, b = {0}
[codex:result] [0x000011db] ### register PF: a = {-1}, b = {0}
[codex:result] [0x000011db] ### register SF: a = {0}, b = {0}
[codex:result] [0x000011db] ### register ZF: a = {0}, b = {0}
[codex:result] [0x000011db] ### register eax: a = [--..--], b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register edx: a = [--..--], b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = {0x3FD8}, b = {1}
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or ([1..0xFFFFFFFF] :
                                                                  (char(1))[
                                                                    {0}].0*)
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> {0}
               PF -> [--..--]
               AF -> {0}
               ZF -> {0}
               SF -> {0}
               TF -> {0x0}
               DF -> [--..--]
               OF -> {0}
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> {1; 0x3FD8}
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 1 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> {0; 1}

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1517)> new <(b:1521)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1517)> new <(b:1522)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1526)> new <(b:1530)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1526)> new <(b:1531)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1535)> new <(b:1539)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1535)> new <(b:1540)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1550)> new <(b:1554)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1550)> new <(b:1555)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1579)> new <(b:1583)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1579)> new <(b:1584)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1591)> new <(b:1595)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1591)> new <(b:1596)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1591)> new <(b:1599)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1591)> new <(b:1600)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> {0; 1}

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset {0; 1} when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:1630)> new <(b:1634)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:1630)> new <(b:1635)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + {0; 1}[0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> {0}
PF -> Bofbool { [--..--] of size 1 }
AF -> {0}
SF -> {0}
OF -> {0}
res32 -> {1; 2}

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> [--..--]
                   AF -> {0}
                   ZF -> {0}
                   SF -> {0}
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> {0}
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> {1; 0x3FD8}
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> {0}
                   ZF -> {0}
                   SF -> {0}
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> {0}
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> {1; 2}
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = {0}, b = {0}
[codex:result] [0x000011db] ### register CF: a = {0}, b = {0}
[codex:result] [0x000011db] ### register OF: a = {0}, b = {0}
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = {0}, b = {0}
[codex:result] [0x000011db] ### register ZF: a = {0}, b = {0}
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = {1; 0x3FD8}, b = {1; 2}
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or ([1..0xFFFFFFFF] :
                                                                  (char(1))[
                                                                    {0}].0* + 
                                                                    {0; 1})
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> {0}
               PF -> [--..--]
               AF -> {0}
               ZF -> {0}
               SF -> {0}
               TF -> {0x0}
               DF -> [--..--]
               OF -> {0}
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [1..0x3FD8]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 2 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [0..0x7FFFFFFF]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1734)> new <(b:1738)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1734)> new <(b:1739)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1743)> new <(b:1747)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1743)> new <(b:1748)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1752)> new <(b:1756)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1752)> new <(b:1757)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1767)> new <(b:1771)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1767)> new <(b:1772)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1796)> new <(b:1800)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1796)> new <(b:1801)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1808)> new <(b:1812)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1808)> new <(b:1813)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1808)> new <(b:1816)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:1808)> new <(b:1817)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> [0..0x7FFFFFFF]

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset [0..0x7FFFFFFF] when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:1847)> new <(b:1851)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:1847)> new <(b:1852)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + [0..0x7FFFFFFF])
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + [0..0x7FFFFFFF])

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + [0..0x7FFFFFFF][0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:1893)> new <(b:1897)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:1893)> new <(b:1898)>
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:1902)> new <(b:1906)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:1902)> new <(b:1907)>
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> {0}
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [1..0x80000000]

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or ([1..0xFFFFFFFF] :
                                      (char(1))[{0}].0* + {0; 1})
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> [--..--]
                   AF -> {0}
                   ZF -> {0}
                   SF -> {0}
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> {0}
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0x3FD8]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([1..0xFFFFFFFF] :
                          (char(1))[{0}].0* + [0..0x7FFFFFFF])
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> [--..--]
                   ZF -> {0}
                   SF -> Bofbool { [--..--] of size 1 }
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0x80000000]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = {0}, b = [--..--]
[codex:result] [0x000011db] ### register CF: a = {0}, b = {0}
[codex:result] [0x000011db] ### register OF: a = {0}, b = [--..--]
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = {0}, b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register ZF: a = {0}, b = {0}
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1}),
               b = ([1..0xFFFFFFFF] : (char(1))[{0}].0* + [0..0x7FFFFFFF])
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [1..0x3FD8], b =
               [1..0x80000000]
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or ([1..0xFFFFFFFF] :
                                                                  (char(1))[
                                                                    {0}].0* + [0..0x7FFFFFFF])
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> {0}
               PF -> [--..--]
               AF -> [--..--]
               ZF -> {0}
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [1..0xFFFFFFFF]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 3 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [--..--]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1961)> new <(b:1965)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1961)> new <(b:1966)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1970)> new <(b:1974)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1970)> new <(b:1975)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1979)> new <(b:1983)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1979)> new <(b:1984)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1994)> new <(b:1998)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1994)> new <(b:1999)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2023)> new <(b:2027)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2023)> new <(b:2028)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2035)> new <(b:2039)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2035)> new <(b:2040)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2035)> new <(b:2043)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2035)> new <(b:2044)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> [--..--]

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset [--..--] when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:2073)> new <(b:2077)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:2073)> new <(b:2078)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([--..--] : (char(1))[{0}].0* + [--..--])

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + [--..--][0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:2123)> new <(b:2127)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:2123)> new <(b:2128)>
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:2132)> new <(b:2136)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:2132)> new <(b:2137)>
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or ([1..0xFFFFFFFF] :
                                      (char(1))[{0}].0* + [0..0x7FFFFFFF])
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> {0}
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> [--..--]
                   ZF -> Bofbool { [--..--] of size 1 }
                   SF -> Bofbool { [--..--] of size 1 }
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [--..--]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register CF: a = {0}, b = [--..--]
[codex:result] [0x000011db] ### register OF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register ZF: a = {0}, b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or ([1..0xFFFFFFFF] :
                             (char(1))[{0}].0* + [0..0x7FFFFFFF]), b =
               ([--..--] : (char(1))[{0}].0* + [--..--])
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [1..0xFFFFFFFF], b =
               [--..--]
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or ([--..--] :
                                                                  (char(1))[
                                                                    {0}].0* + [--..--])
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [--..--]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 4 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [--..--]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2197)> new <(b:2201)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2197)> new <(b:2202)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2206)> new <(b:2210)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2206)> new <(b:2211)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2215)> new <(b:2219)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2215)> new <(b:2220)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2230)> new <(b:2234)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2230)> new <(b:2235)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2259)> new <(b:2263)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2259)> new <(b:2264)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2271)> new <(b:2275)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2271)> new <(b:2276)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2271)> new <(b:2279)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2271)> new <(b:2280)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> [--..--]

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset [--..--] when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:2309)> new <(b:2313)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:2309)> new <(b:2314)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([--..--] : (char(1))[{0}].0* + [--..--])

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + [--..--][0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:2359)> new <(b:2363)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:2359)> new <(b:2364)>
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:2368)> new <(b:2372)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:2368)> new <(b:2373)>
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or ([--..--] : (char(1))[{0}].0* + [--..--])
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [--..--]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> [--..--]
                   ZF -> Bofbool { [--..--] of size 1 }
                   SF -> Bofbool { [--..--] of size 1 }
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [--..--]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register CF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register OF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register ZF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or ([--..--] : (char(1))[{0}].0* + [--..--]), b =
               ([--..--] : (char(1))[{0}].0* + [--..--])
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [--..--], b = [--..--]
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = true
[codex:result] [0x000011db]
               fixpoint reached, result: eax -> [--..--] or ([--..--] :
                                                              (char(1))[
                                                                {0}].0* + [--..--])
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [--..--]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Finished analyzing star.
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [--..--]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2434)> new <(b:2438)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2434)> new <(b:2439)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2443)> new <(b:2447)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2443)> new <(b:2448)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2452)> new <(b:2456)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2452)> new <(b:2457)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2467)> new <(b:2471)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2467)> new <(b:2472)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2496)> new <(b:2500)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2496)> new <(b:2501)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2508)> new <(b:2512)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2508)> new <(b:2513)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2508)> new <(b:2516)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2508)> new <(b:2517)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e7] analyze_regex, case Append, src = 0x000011e7
[codex:result] [0x000011e7]
               address: 0x000011e7
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011ea, 0) 
                      
[codex:result] [0x000011e7] edge from 0 to 1
[codex:result] [0x000011e7] -check- ptr_arith
[codex:result] [0x000011e7] -check- array_offset_access
[codex:result] [0x000011e7]
               changes at entry of successor 0 (0x000011ea)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011e7] debug_log = false
[codex:result] [0x000011ea] analyze_regex, case Append, src = 0x000011ea
[codex:result] [0x000011ea]
               address: 0x000011ea
               instruction: mov eax, [eax]
               dhunk:  0: eax<32> := @[eax<32>,4];
                       1: goto (0x000011ec, 0) 
                      
[codex:result] [0x000011ea] edge from 0 to 1
[codex:result] [0x000011ea] -check- array_offset_access
[1;31m[codex:error] [0x000011ea] -alarm- -alarm- invalid_load_access[0m[0m
[codex:result] [0x000011ea] -check- load_param_nonptr
[codex:result] [0x000011ea] -check- load_param_nonptr_old
[codex:result] [0x000011ea] -check- load_param_nonptr_old
[codex:result] [0x000011ea]
               changes at entry of successor 0 (0x000011ec)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011ea] debug_log = false
[codex:result] [0x000011ec] analyze_regex, case Append, src = 0x000011ec
[codex:result] [0x000011ec]
               address: 0x000011ec
               instruction: mov [ebp + 0xfffffffc], eax
               dhunk:  0: @[(ebp<32> + -4<32>),4] := eax<32>;
                       1: goto (0x000011ef, 0) 
                      
[codex:result] [0x000011ec] edge from 0 to 1
[codex:result] [0x000011ec] -check- ptr_arith
[codex:result] [0x000011ec] changes at entry of successor 0 (0x000011ef)
                            
[codex:result] [0x000011ec] debug_log = false
[codex:result] [0x000011ef] analyze_regex, case Append, src = 0x000011ef
[codex:result] [0x000011ef]
               address: 0x000011ef
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011f2, 0) 
                      
[codex:result] [0x000011ef] edge from 0 to 1
[codex:result] [0x000011ef] -check- ptr_arith
[codex:result] [0x000011ef] -check- array_offset_access
[codex:result] [0x000011ef] changes at entry of successor 0 (0x000011f2)
                            
[codex:result] [0x000011ef] debug_log = false
[codex:result] [0x000011f2] analyze_regex, case Append, src = 0x000011f2
[codex:result] [0x000011f2]
               address: 0x000011f2
               instruction: cmp eax, [ebp + 0xfffffff4]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -12<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -9<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -12<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -12<32>),4]);
                       7: goto (0x000011f5, 0) 
                      
[codex:result] [0x000011f2] edge from 0 to 1
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2] -check- ptr_arith
[1;31m[codex:error] [0x000011f2] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011f2] edge from 1 to 2
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:2545)> new <(b:2549)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:2545)> new <(b:2550)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:2554)> new <(b:2558)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:2554)> new <(b:2559)>
[codex:result] [0x000011f2] edge from 2 to 3
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:2563)> new <(b:2567)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:2563)> new <(b:2568)>
[codex:result] [0x000011f2] edge from 3 to 4
[codex:result] [0x000011f2] edge from 4 to 5
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:2580)> new <(b:2584)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:2580)> new <(b:2585)>
[codex:result] [0x000011f2] edge from 5 to 6
[codex:result] [0x000011f2] edge from 6 to 7
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:2609)> new <(b:2613)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:2609)> new <(b:2614)>
[codex:result] [0x000011f2]
               changes at entry of successor 0 (0x000011f5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011f2] debug_log = false
[codex:result] [0x000011f5] analyze_regex, case Append, src = 0x000011f5
[codex:result] [0x000011f5]
               address: 0x000011f5
               instruction: jnz 0x11c4
               dhunk:  0: if ! (ZF<1>) goto (0x000011c4, 0) else goto 1
                       1: goto (0x000011f7, 0) 
                      
[codex:result] [0x000011f5] edge from 0 to 1
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:2571)> new <(b:2617)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:2571)> new <(b:2618)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:2571)> new <(b:2621)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:2571)> new <(b:2622)>
[codex:result] [0x000011f5] changes at entry of successor 0 (0x000011f7)
                            
[codex:result] [0x000011f5] debug_log = false
[codex:result] [0x000011f5] changes at entry of successor 1 (0x000011c4)
                            
[codex:result] [0x000011f5] debug_log = false
[codex:result] [0x000011f5]
               fixpoint between:
                 entry
                 eax -> [--..--]
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--]
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> {-1}
                   AF -> {0x0}
                   ZF -> {0}
                   SF -> {0}
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> {0}
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> {0x3FD8}
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> Bofbool { [--..--] of size 1 }
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> Bofbool { [--..--] of size 1 }
                   ZF -> Bofbool { [--..--] of size 1 }
                   SF -> Bofbool { [--..--] of size 1 }
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011f5] ### register AF: a = {0x0}, b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011f5] ### register CF: a = {0}, b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011f5] ### register OF: a = {0}, b = [--..--]
[codex:result] [0x000011f5] ### register PF: a = {-1}, b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011f5] ### register SF: a = {0}, b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011f5] ### register ZF: a = {0}, b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011f5] ### register eax: a = [--..--], b =
               ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)
[codex:result] [0x000011f5] ### register edx: a = [--..--], b =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011f5] ### register res32: a = {0x3FD8}, b =
               [1..0xFFFFFFFF]
[codex:result] [0x000011f5] After serialize: included = true
[codex:result] [0x000011f5] After fixpoint: fp = false
[codex:result] [0x000011f5]
               fixpoint not reached, result: eax -> [--..--] or ([1..0xFFFFFFFF] :
                                                                  (Name(
                                                                    struct message))[
                                                                    {0}].0*)
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [1..0xFFFFFFFF]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011f5] Mu iteration 1 ...
[codex:result] [0x000011c4] analyze_regex, case Append, src = 0x000011c4
[codex:result] [0x000011c4]
               address: 0x000011c4
               instruction: mov [ebp + 0xfffffff8], 0x0
               dhunk:  0: @[(ebp<32> + -8<32>),4] := 0<32>;
                       1: goto (0x000011cb, 0) 
                      
[codex:result] [0x000011c4] edge from 0 to 1
[codex:result] [0x000011c4] -check- ptr_arith
[codex:result] [0x000011c4] changes at entry of successor 0 (0x000011cb)
                            
[codex:result] [0x000011c4] debug_log = false
[codex:result] [0x000011cb] analyze_regex, case Append, src = 0x000011cb
[codex:result] [0x000011cb]
               address: 0x000011cb
               instruction: jmp 0x11df
               dhunk:  0: goto (0x000011df, 0) 
                      
[codex:result] [0x000011cb] changes at entry of successor 0 (0x000011df)
                            
[codex:result] [0x000011cb] debug_log = false
[codex:result] [0x000011cb] Analyzing star...
[codex:result] [0x000011cb] Mu iteration 0 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> {0}

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1350)> new <(b:2654)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1350)> new <(b:2655)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1359)> new <(b:2658)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1359)> new <(b:2659)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1368)> new <(b:2663)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1368)> new <(b:2664)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1384)> new <(b:2669)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1384)> new <(b:2670)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1413)> new <(b:2675)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1413)> new <(b:2676)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2683)> new <(b:2687)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2683)> new <(b:2688)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2683)> new <(b:2691)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2683)> new <(b:2692)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> {0}

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:2717)> new <(b:2723)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:2717)> new <(b:2724)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
CF -> {0}
PF -> Bofbool { [--..--] of size 1 }
AF -> {0}
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- load_param_nonptr
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> {0}
PF -> {0}
AF -> {0}
SF -> {0}
OF -> {0}
res32 -> {1}

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or ([1..0xFFFFFFFF] :
                                      (Name(struct message))[{0}].0*)
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> {0}
                   AF -> {0}
                   ZF -> {0}
                   SF -> {0}
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> {0}
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> {1}
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register CF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register OF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register PF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register SF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register ZF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*),
               b = ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] -check- serialize
[codex:result] [0x000011db] -check- serialize
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [1..0xFFFFFFFF], b = {1}
[codex:result] [0x000011db] After serialize: included = false
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or [1..0xFFFFFFFF]
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [1..0xFFFFFFFF]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 1 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> {0; 1}

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2782)> new <(b:2786)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2782)> new <(b:2787)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2791)> new <(b:2795)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2791)> new <(b:2796)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2800)> new <(b:2804)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2800)> new <(b:2805)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2815)> new <(b:2819)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2815)> new <(b:2820)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2844)> new <(b:2848)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2844)> new <(b:2849)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2856)> new <(b:2860)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2856)> new <(b:2861)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2856)> new <(b:2864)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:2856)> new <(b:2865)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> {0; 1}

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset {0; 1} when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:2895)> new <(b:2899)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:2895)> new <(b:2900)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + {0; 1}[0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> {0}
PF -> Bofbool { [--..--] of size 1 }
AF -> {0}
SF -> {0}
OF -> {0}
res32 -> {1; 2}

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or [1..0xFFFFFFFF]
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> {0}
                   ZF -> {0}
                   SF -> {0}
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> {0}
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> {1; 2}
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register CF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register OF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register ZF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or [1..0xFFFFFFFF], b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [1..0xFFFFFFFF], b =
               {1; 2}
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or [1..0xFFFFFFFF]
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [1..0xFFFFFFFF]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 2 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [0..0x7FFFFFFF]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2997)> new <(b:3001)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:2997)> new <(b:3002)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3006)> new <(b:3010)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3006)> new <(b:3011)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3015)> new <(b:3019)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3015)> new <(b:3020)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3030)> new <(b:3034)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3030)> new <(b:3035)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3059)> new <(b:3063)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3059)> new <(b:3064)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3071)> new <(b:3075)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3071)> new <(b:3076)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3071)> new <(b:3079)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3071)> new <(b:3080)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> [0..0x7FFFFFFF]

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset [0..0x7FFFFFFF] when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:3110)> new <(b:3114)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:3110)> new <(b:3115)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + [0..0x7FFFFFFF])
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + [0..0x7FFFFFFF])

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + [0..0x7FFFFFFF][0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3155)> new <(b:3159)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3155)> new <(b:3160)>
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3164)> new <(b:3168)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3164)> new <(b:3169)>
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> {0}
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [1..0x80000000]

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or [1..0xFFFFFFFF]
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([1..0xFFFFFFFF] :
                          (char(1))[{0}].0* + [0..0x7FFFFFFF])
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> [--..--]
                   ZF -> {0}
                   SF -> Bofbool { [--..--] of size 1 }
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0x80000000]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register CF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register OF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register ZF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or [1..0xFFFFFFFF], b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0* + [0..0x7FFFFFFF])
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [1..0xFFFFFFFF], b =
               [1..0x80000000]
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or [1..0xFFFFFFFF]
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [1..0xFFFFFFFF]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 3 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [--..--]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3223)> new <(b:3227)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3223)> new <(b:3228)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3232)> new <(b:3236)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3232)> new <(b:3237)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3241)> new <(b:3245)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3241)> new <(b:3246)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3256)> new <(b:3260)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3256)> new <(b:3261)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3285)> new <(b:3289)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3285)> new <(b:3290)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3297)> new <(b:3301)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3297)> new <(b:3302)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3297)> new <(b:3305)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3297)> new <(b:3306)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> [--..--]

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset [--..--] when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:3335)> new <(b:3339)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:3335)> new <(b:3340)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([--..--] : (char(1))[{0}].0* + [--..--])

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + [--..--][0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3385)> new <(b:3389)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3385)> new <(b:3390)>
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3394)> new <(b:3398)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3394)> new <(b:3399)>
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or [1..0xFFFFFFFF]
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> [--..--]
                   ZF -> Bofbool { [--..--] of size 1 }
                   SF -> Bofbool { [--..--] of size 1 }
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [--..--]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register CF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register OF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register ZF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or [1..0xFFFFFFFF], b =
               ([--..--] : (char(1))[{0}].0* + [--..--])
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [1..0xFFFFFFFF], b =
               [--..--]
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or [--..--]
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [--..--]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 4 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [--..--]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3458)> new <(b:3462)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3458)> new <(b:3463)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3467)> new <(b:3471)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3467)> new <(b:3472)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3476)> new <(b:3480)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3476)> new <(b:3481)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3491)> new <(b:3495)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3491)> new <(b:3496)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3520)> new <(b:3524)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3520)> new <(b:3525)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3532)> new <(b:3536)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3532)> new <(b:3537)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3532)> new <(b:3540)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3532)> new <(b:3541)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> [--..--]

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset [--..--] when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:3570)> new <(b:3574)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:3570)> new <(b:3575)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([--..--] : (char(1))[{0}].0* + [--..--])

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + [--..--][0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3620)> new <(b:3624)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3620)> new <(b:3625)>
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3629)> new <(b:3633)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:3629)> new <(b:3634)>
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or [--..--]
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [--..--]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> [--..--]
                   ZF -> Bofbool { [--..--] of size 1 }
                   SF -> Bofbool { [--..--] of size 1 }
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [--..--]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register CF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register OF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register ZF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register eax: a = [--..--] or [--..--], b =
               ([--..--] : (char(1))[{0}].0* + [--..--])
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [--..--], b = [--..--]
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = true
[codex:result] [0x000011db]
               fixpoint reached, result: eax -> [--..--] or [--..--]
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [--..--]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Finished analyzing star.
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [--..--]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3694)> new <(b:3698)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3694)> new <(b:3699)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3703)> new <(b:3707)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3703)> new <(b:3708)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3712)> new <(b:3716)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3712)> new <(b:3717)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3727)> new <(b:3731)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3727)> new <(b:3732)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3756)> new <(b:3760)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:3756)> new <(b:3761)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3768)> new <(b:3772)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3768)> new <(b:3773)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3768)> new <(b:3776)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3768)> new <(b:3777)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e7] analyze_regex, case Append, src = 0x000011e7
[codex:result] [0x000011e7]
               address: 0x000011e7
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011ea, 0) 
                      
[codex:result] [0x000011e7] edge from 0 to 1
[codex:result] [0x000011e7] -check- ptr_arith
[codex:result] [0x000011e7] -check- array_offset_access
[codex:result] [0x000011e7]
               changes at entry of successor 0 (0x000011ea)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011e7] debug_log = false
[codex:result] [0x000011ea] analyze_regex, case Append, src = 0x000011ea
[codex:result] [0x000011ea]
               address: 0x000011ea
               instruction: mov eax, [eax]
               dhunk:  0: eax<32> := @[eax<32>,4];
                       1: goto (0x000011ec, 0) 
                      
[codex:result] [0x000011ea] edge from 0 to 1
[codex:result] [0x000011ea] -check- array_offset_access
[1;31m[codex:error] [0x000011ea] -alarm- -alarm- invalid_load_access[0m[0m
[codex:result] [0x000011ea] -check- load_param_nonptr
[codex:result] [0x000011ea] -check- load_param_nonptr_old
[codex:result] [0x000011ea] -check- load_param_nonptr_old
[codex:result] [0x000011ea]
               changes at entry of successor 0 (0x000011ec)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011ea] debug_log = false
[codex:result] [0x000011ec] analyze_regex, case Append, src = 0x000011ec
[codex:result] [0x000011ec]
               address: 0x000011ec
               instruction: mov [ebp + 0xfffffffc], eax
               dhunk:  0: @[(ebp<32> + -4<32>),4] := eax<32>;
                       1: goto (0x000011ef, 0) 
                      
[codex:result] [0x000011ec] edge from 0 to 1
[codex:result] [0x000011ec] -check- ptr_arith
[codex:result] [0x000011ec] changes at entry of successor 0 (0x000011ef)
                            
[codex:result] [0x000011ec] debug_log = false
[codex:result] [0x000011ef] analyze_regex, case Append, src = 0x000011ef
[codex:result] [0x000011ef]
               address: 0x000011ef
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011f2, 0) 
                      
[codex:result] [0x000011ef] edge from 0 to 1
[codex:result] [0x000011ef] -check- ptr_arith
[codex:result] [0x000011ef] -check- array_offset_access
[codex:result] [0x000011ef] changes at entry of successor 0 (0x000011f2)
                            
[codex:result] [0x000011ef] debug_log = false
[codex:result] [0x000011f2] analyze_regex, case Append, src = 0x000011f2
[codex:result] [0x000011f2]
               address: 0x000011f2
               instruction: cmp eax, [ebp + 0xfffffff4]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -12<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -9<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -12<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -12<32>),4]);
                       7: goto (0x000011f5, 0) 
                      
[codex:result] [0x000011f2] edge from 0 to 1
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2] -check- ptr_arith
[1;31m[codex:error] [0x000011f2] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011f2] edge from 1 to 2
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:3803)> new <(b:3807)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:3803)> new <(b:3808)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:3812)> new <(b:3816)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:3812)> new <(b:3817)>
[codex:result] [0x000011f2] edge from 2 to 3
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:3821)> new <(b:3825)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:3821)> new <(b:3826)>
[codex:result] [0x000011f2] edge from 3 to 4
[codex:result] [0x000011f2] edge from 4 to 5
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:3836)> new <(b:3840)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:3836)> new <(b:3841)>
[codex:result] [0x000011f2] edge from 5 to 6
[codex:result] [0x000011f2] edge from 6 to 7
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:3865)> new <(b:3869)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:3865)> new <(b:3870)>
[codex:result] [0x000011f2]
               changes at entry of successor 0 (0x000011f5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011f2] debug_log = false
[codex:result] [0x000011f5] analyze_regex, case Append, src = 0x000011f5
[codex:result] [0x000011f5]
               address: 0x000011f5
               instruction: jnz 0x11c4
               dhunk:  0: if ! (ZF<1>) goto (0x000011c4, 0) else goto 1
                       1: goto (0x000011f7, 0) 
                      
[codex:result] [0x000011f5] edge from 0 to 1
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:3829)> new <(b:3873)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:3829)> new <(b:3874)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:3829)> new <(b:3877)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:3829)> new <(b:3878)>
[codex:result] [0x000011f5] changes at entry of successor 0 (0x000011f7)
                            
[codex:result] [0x000011f5] debug_log = false
[codex:result] [0x000011f5] changes at entry of successor 1 (0x000011c4)
                            
[codex:result] [0x000011f5] debug_log = false
[codex:result] [0x000011f5]
               fixpoint between:
                 entry
                 eax -> [--..--] or ([1..0xFFFFFFFF] :
                                      (Name(struct message))[{0}].0*)
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> Bofbool { [--..--] of size 1 }
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> Bofbool { [--..--] of size 1 }
                   ZF -> Bofbool { [--..--] of size 1 }
                   SF -> Bofbool { [--..--] of size 1 }
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011f5] ### register AF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011f5] ### register CF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011f5] ### register OF: a = [--..--], b = [--..--]
[codex:result] [0x000011f5] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011f5] ### register SF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011f5] ### register ZF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011f5] ### register eax: a =
               [--..--] or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*),
               b = ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)
[codex:result] [0x000011f5] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011f5] ### register res32: a = [1..0xFFFFFFFF], b =
               [1..0xFFFFFFFF]
[codex:result] [0x000011f5] After serialize: included = true
[codex:result] [0x000011f5] After fixpoint: fp = true
[codex:result] [0x000011f5]
               fixpoint reached, result: eax -> [--..--] or ([1..0xFFFFFFFF] :
                                                              (Name(struct message))[
                                                                {0}].0*)
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [1..0xFFFFFFFF]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011f5] Finished analyzing star.
[codex:result] [0x000011c4] analyze_regex, case Append, src = 0x000011c4
[codex:result] [0x000011c4]
               address: 0x000011c4
               instruction: mov [ebp + 0xfffffff8], 0x0
               dhunk:  0: @[(ebp<32> + -8<32>),4] := 0<32>;
                       1: goto (0x000011cb, 0) 
                      
[codex:result] [0x000011c4] edge from 0 to 1
[codex:result] [0x000011c4] -check- ptr_arith
[codex:result] [0x000011c4] changes at entry of successor 0 (0x000011cb)
                            
[codex:result] [0x000011c4] debug_log = false
[codex:result] [0x000011cb] analyze_regex, case Append, src = 0x000011cb
[codex:result] [0x000011cb]
               address: 0x000011cb
               instruction: jmp 0x11df
               dhunk:  0: goto (0x000011df, 0) 
                      
[codex:result] [0x000011cb] changes at entry of successor 0 (0x000011df)
                            
[codex:result] [0x000011cb] debug_log = false
[codex:result] [0x000011cb] Analyzing star...
[codex:result] [0x000011cb] Mu iteration 0 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> {0}

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1350)> new <(b:3913)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1350)> new <(b:3914)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1359)> new <(b:3917)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1359)> new <(b:3918)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1368)> new <(b:3922)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1368)> new <(b:3923)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1384)> new <(b:3928)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1384)> new <(b:3929)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1413)> new <(b:3934)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:1413)> new <(b:3935)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3942)> new <(b:3946)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3942)> new <(b:3947)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3942)> new <(b:3950)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:3942)> new <(b:3951)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> {0}

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:3976)> new <(b:3982)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:3976)> new <(b:3983)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
CF -> {0}
PF -> Bofbool { [--..--] of size 1 }
AF -> {0}
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- load_param_nonptr
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> {0}
PF -> {0}
AF -> {0}
SF -> {0}
OF -> {0}
res32 -> {1}

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or ([1..0xFFFFFFFF] :
                                      (Name(struct message))[{0}].0*)
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> {0}
                   AF -> {0}
                   ZF -> {0}
                   SF -> {0}
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> {0}
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> {1}
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register CF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register OF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register PF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register SF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register ZF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*),
               b = ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] -check- serialize
[codex:result] [0x000011db] -check- serialize
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [1..0xFFFFFFFF], b = {1}
[codex:result] [0x000011db] After serialize: included = false
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or [1..0xFFFFFFFF]
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [1..0xFFFFFFFF]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 1 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> {0; 1}

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4041)> new <(b:4045)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4041)> new <(b:4046)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4050)> new <(b:4054)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4050)> new <(b:4055)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4059)> new <(b:4063)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4059)> new <(b:4064)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4074)> new <(b:4078)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4074)> new <(b:4079)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4103)> new <(b:4107)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4103)> new <(b:4108)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4115)> new <(b:4119)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4115)> new <(b:4120)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4115)> new <(b:4123)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4115)> new <(b:4124)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> {0; 1}

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset {0; 1} when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:4154)> new <(b:4158)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:4154)> new <(b:4159)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + {0; 1}[0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> {0}
PF -> Bofbool { [--..--] of size 1 }
AF -> {0}
SF -> {0}
OF -> {0}
res32 -> {1; 2}

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or [1..0xFFFFFFFF]
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> {0}
                   ZF -> {0}
                   SF -> {0}
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> {0}
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> {1; 2}
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register CF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register OF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register ZF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or [1..0xFFFFFFFF], b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0* + {0; 1})
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [1..0xFFFFFFFF], b =
               {1; 2}
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or [1..0xFFFFFFFF]
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [1..0xFFFFFFFF]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 2 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [0..0x7FFFFFFF]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4256)> new <(b:4260)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4256)> new <(b:4261)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4265)> new <(b:4269)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4265)> new <(b:4270)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4274)> new <(b:4278)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4274)> new <(b:4279)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4289)> new <(b:4293)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4289)> new <(b:4294)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4318)> new <(b:4322)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4318)> new <(b:4323)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4330)> new <(b:4334)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4330)> new <(b:4335)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4330)> new <(b:4338)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4330)> new <(b:4339)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> [0..0x7FFFFFFF]

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset [0..0x7FFFFFFF] when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:4369)> new <(b:4373)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:4369)> new <(b:4374)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + [0..0x7FFFFFFF])
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([1..0xFFFFFFFF] : (char(1))[{0}].0* + [0..0x7FFFFFFF])

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + [0..0x7FFFFFFF][0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4414)> new <(b:4418)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4414)> new <(b:4419)>
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4423)> new <(b:4427)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4423)> new <(b:4428)>
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> {0}
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [1..0x80000000]

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or [1..0xFFFFFFFF]
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([1..0xFFFFFFFF] :
                          (char(1))[{0}].0* + [0..0x7FFFFFFF])
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> {0}
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> [--..--]
                   ZF -> {0}
                   SF -> Bofbool { [--..--] of size 1 }
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0x80000000]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register CF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register OF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register ZF: a = [--..--], b = {0}
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or [1..0xFFFFFFFF], b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0* + [0..0x7FFFFFFF])
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [1..0xFFFFFFFF], b =
               [1..0x80000000]
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or [1..0xFFFFFFFF]
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [1..0xFFFFFFFF]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 3 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [--..--]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4482)> new <(b:4486)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4482)> new <(b:4487)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4491)> new <(b:4495)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4491)> new <(b:4496)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4500)> new <(b:4504)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4500)> new <(b:4505)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4515)> new <(b:4519)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4515)> new <(b:4520)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4544)> new <(b:4548)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4544)> new <(b:4549)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4556)> new <(b:4560)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4556)> new <(b:4561)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4556)> new <(b:4564)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4556)> new <(b:4565)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> [--..--]

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset [--..--] when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:4594)> new <(b:4598)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:4594)> new <(b:4599)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([--..--] : (char(1))[{0}].0* + [--..--])

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + [--..--][0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4644)> new <(b:4648)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4644)> new <(b:4649)>
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4653)> new <(b:4657)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4653)> new <(b:4658)>
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or [1..0xFFFFFFFF]
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [1..0xFFFFFFFF]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> [--..--]
                   ZF -> Bofbool { [--..--] of size 1 }
                   SF -> Bofbool { [--..--] of size 1 }
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [--..--]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register CF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register OF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register ZF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register eax: a =
               [--..--] or [1..0xFFFFFFFF], b =
               ([--..--] : (char(1))[{0}].0* + [--..--])
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [1..0xFFFFFFFF], b =
               [--..--]
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = false
[codex:result] [0x000011db]
               fixpoint not reached, result: eax -> [--..--] or [--..--]
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [--..--]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Mu iteration 4 ...
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [--..--]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4717)> new <(b:4721)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4717)> new <(b:4722)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4726)> new <(b:4730)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4726)> new <(b:4731)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4735)> new <(b:4739)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4735)> new <(b:4740)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4750)> new <(b:4754)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4750)> new <(b:4755)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4779)> new <(b:4783)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4779)> new <(b:4784)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4791)> new <(b:4795)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4791)> new <(b:4796)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4791)> new <(b:4799)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:4791)> new <(b:4800)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> [--..--]

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset [--..--] when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:4829)> new <(b:4833)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:4829)> new <(b:4834)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([--..--] : (char(1))[{0}].0* + [--..--])

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + [--..--][0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011db] analyze_regex, case Append, src = 0x000011db
[codex:result] [0x000011db]
               address: 0x000011db
               instruction: add [ebp + 0xfffffff8], 0x1
               dhunk:  0: res32<32> := (@[(ebp<32> + -8<32>),4] + 1<32>);
                       1: OF<1> :=
                           (! (@[(ebp<32> + -5<32>),1]{7}) &
                            (@[(ebp<32> + -5<32>),1]{7} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu @[(ebp<32> + -8<32>),1]{0,3} 5) + 1<5>){4};
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu @[(ebp<32> + -8<32>),4] 33) + 1<33>){32};
                       7: @[(ebp<32> + -8<32>),4] := res32<32>;
                       8: goto (0x000011df, 0) 
                      
[codex:result] [0x000011db] edge from 0 to 1
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 1 to 2
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4879)> new <(b:4883)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4879)> new <(b:4884)>
[codex:result] [0x000011db] edge from 2 to 3
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4888)> new <(b:4892)>
[codex:result] [0x000011db]
               found boolean by bdd: old <(b:4888)> new <(b:4893)>
[codex:result] [0x000011db] edge from 3 to 4
[codex:result] [0x000011db] edge from 4 to 5
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 5 to 6
[codex:result] [0x000011db] edge from 6 to 7
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] -check- array_offset_access
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db] edge from 7 to 8
[codex:result] [0x000011db] -check- ptr_arith
[codex:result] [0x000011db]
               changes at entry of successor 0 (0x000011df)
               CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011db] debug_log = false
[codex:result] [0x000011db]
               fixpoint between:
                 entry
                 eax -> [--..--] or [--..--]
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> [--..--]
                   AF -> [--..--]
                   ZF -> [--..--]
                   SF -> [--..--]
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [--..--]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
                 exit
                 eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
                   ebx -> [--..--]
                   ecx -> [--..--]
                   edx -> ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
                   edi -> [--..--]
                   esp -> {0xFFEC}
                   ebp -> {0xFFFC}
                   esi -> [--..--]
                   div64 -> [--..--]
                   quo64 -> [--..--]
                   rem64 -> [--..--]
                   CF -> [--..--]
                   PF -> Bofbool { [--..--] of size 1 }
                   AF -> [--..--]
                   ZF -> Bofbool { [--..--] of size 1 }
                   SF -> Bofbool { [--..--] of size 1 }
                   TF -> {0x0}
                   DF -> [--..--]
                   OF -> [--..--]
                   NT -> {0x0}
                   RF -> {0x0}
                   AC -> [--..--]
                   ID -> [--..--]
                   IF -> {0x0}
                   IOPL -> [--..--]
                   VIF -> [--..--]
                   VIP -> [--..--]
                   VM -> {0x0}
                   cpl -> [--..--]
                   cs -> [--..--]
                   ds -> [--..--]
                   ss -> [--..--]
                   es -> [--..--]
                   fs -> [--..--]
                   gs -> [--..--]
                   tr -> [--..--]
                   res8 -> [--..--]
                   res16 -> [--..--]
                   res32 -> [--..--]
                   temp32 -> [--..--]
                   temp32_0 -> [--..--]
                   temp32_1 -> [--..--]
                   temp32_2 -> [--..--]
                   temp32_3 -> [--..--]
                   temp64 -> [--..--]
                   res64 -> [--..--]
                   gdt -> [--..--]
                   ds_base -> {0x0}
                   cs_base -> {0x0}
                   ss_base -> {0x0}
                   es_base -> [--..--]
                   fs_base -> [--..--]
                   gs_base -> [--..--]
                   tr_base -> [--..--]
                   ds_desc -> [--..--]
                   cs_desc -> [--..--]
                   ss_desc -> [--..--]
                   es_desc -> [--..--]
                   fs_desc -> [--..--]
                   gs_desc -> [--..--]
                   tr_desc -> [--..--]
                   idt -> [--..--]
                   mm0 -> [--..--]
                   
[codex:result] [0x000011db] ### register AF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register CF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register OF: a = [--..--], b = [--..--]
[codex:result] [0x000011db] ### register PF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register SF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register ZF: a = [--..--], b =
               Bofbool { [--..--] of size 1 }
[codex:result] [0x000011db] ### register eax: a = [--..--] or [--..--], b =
               ([--..--] : (char(1))[{0}].0* + [--..--])
[codex:result] [0x000011db] ### register edx: a =
               [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*), b =
               ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
[codex:result] [0x000011db] ### register res32: a = [--..--], b = [--..--]
[codex:result] [0x000011db] After serialize: included = true
[codex:result] [0x000011db] After fixpoint: fp = true
[codex:result] [0x000011db]
               fixpoint reached, result: eax -> [--..--] or [--..--]
               ebx -> [--..--]
               ecx -> [--..--]
               edx -> [--..--] or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)
               edi -> [--..--]
               esp -> {0xFFEC}
               ebp -> {0xFFFC}
               esi -> [--..--]
               div64 -> [--..--]
               quo64 -> [--..--]
               rem64 -> [--..--]
               CF -> [--..--]
               PF -> [--..--]
               AF -> [--..--]
               ZF -> [--..--]
               SF -> [--..--]
               TF -> {0x0}
               DF -> [--..--]
               OF -> [--..--]
               NT -> {0x0}
               RF -> {0x0}
               AC -> [--..--]
               ID -> [--..--]
               IF -> {0x0}
               IOPL -> [--..--]
               VIF -> [--..--]
               VIP -> [--..--]
               VM -> {0x0}
               cpl -> [--..--]
               cs -> [--..--]
               ds -> [--..--]
               ss -> [--..--]
               es -> [--..--]
               fs -> [--..--]
               gs -> [--..--]
               tr -> [--..--]
               res8 -> [--..--]
               res16 -> [--..--]
               res32 -> [--..--]
               temp32 -> [--..--]
               temp32_0 -> [--..--]
               temp32_1 -> [--..--]
               temp32_2 -> [--..--]
               temp32_3 -> [--..--]
               temp64 -> [--..--]
               res64 -> [--..--]
               gdt -> [--..--]
               ds_base -> {0x0}
               cs_base -> {0x0}
               ss_base -> {0x0}
               es_base -> [--..--]
               fs_base -> [--..--]
               gs_base -> [--..--]
               tr_base -> [--..--]
               ds_desc -> [--..--]
               cs_desc -> [--..--]
               ss_desc -> [--..--]
               es_desc -> [--..--]
               fs_desc -> [--..--]
               gs_desc -> [--..--]
               tr_desc -> [--..--]
               idt -> [--..--]
               mm0 -> [--..--]
               
[codex:result] [0x000011db] Finished analyzing star.
[codex:result] [0x000011df] analyze_regex, case Append, src = 0x000011df
[codex:result] [0x000011df]
               address: 0x000011df
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011e2, 0) 
                      
[codex:result] [0x000011df] edge from 0 to 1
[codex:result] [0x000011df] -check- ptr_arith
[codex:result] [0x000011df] -check- array_offset_access
[codex:result] [0x000011df]
               changes at entry of successor 0 (0x000011e2)
               eax -> [--..--]

[codex:result] [0x000011df] debug_log = false
[codex:result] [0x000011e2] analyze_regex, case Append, src = 0x000011e2
[codex:result] [0x000011e2]
               address: 0x000011e2
               instruction: cmp eax, [ebp + 0xfffffff0]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -16<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -13<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -16<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -16<32>),4]);
                       7: goto (0x000011e5, 0) 
                      
[codex:result] [0x000011e2] edge from 0 to 1
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] edge from 1 to 2
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4953)> new <(b:4957)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4953)> new <(b:4958)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4962)> new <(b:4966)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4962)> new <(b:4967)>
[codex:result] [0x000011e2] edge from 2 to 3
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4971)> new <(b:4975)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4971)> new <(b:4976)>
[codex:result] [0x000011e2] edge from 3 to 4
[codex:result] [0x000011e2] edge from 4 to 5
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4986)> new <(b:4990)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:4986)> new <(b:4991)>
[codex:result] [0x000011e2] edge from 5 to 6
[codex:result] [0x000011e2] edge from 6 to 7
[codex:result] [0x000011e2] -check- ptr_arith
[codex:result] [0x000011e2] -check- array_offset_access
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:5015)> new <(b:5019)>
[codex:result] [0x000011e2]
               found boolean by bdd: old <(b:5015)> new <(b:5020)>
[codex:result] [0x000011e2]
               changes at entry of successor 0 (0x000011e5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011e2] debug_log = false
[codex:result] [0x000011e5] analyze_regex, case Append, src = 0x000011e5
[codex:result] [0x000011e5]
               address: 0x000011e5
               instruction: jl 0x11cd
               dhunk:  0: if (SF<1> <> OF<1>)
                            goto (0x000011cd, 0) else goto 1
                       1: goto (0x000011e7, 0) 
                      
[codex:result] [0x000011e5] edge from 0 to 1
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:5027)> new <(b:5031)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:5027)> new <(b:5032)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:5027)> new <(b:5035)>
[codex:result] [0x000011e5]
               found boolean by bdd: old <(b:5027)> new <(b:5036)>
[codex:result] [0x000011e5] changes at entry of successor 0 (0x000011e7)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e5] changes at entry of successor 1 (0x000011cd)
                            
[codex:result] [0x000011e5] debug_log = false
[codex:result] [0x000011e7] analyze_regex, case Append, src = 0x000011e7
[codex:result] [0x000011e7]
               address: 0x000011e7
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011ea, 0) 
                      
[codex:result] [0x000011e7] edge from 0 to 1
[codex:result] [0x000011e7] -check- ptr_arith
[codex:result] [0x000011e7] -check- array_offset_access
[codex:result] [0x000011e7]
               changes at entry of successor 0 (0x000011ea)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011e7] debug_log = false
[codex:result] [0x000011cd] analyze_regex, case Append, src = 0x000011cd
[codex:result] [0x000011cd]
               address: 0x000011cd
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011d0, 0) 
                      
[codex:result] [0x000011cd] edge from 0 to 1
[codex:result] [0x000011cd] -check- ptr_arith
[codex:result] [0x000011cd] -check- array_offset_access
[codex:result] [0x000011cd]
               changes at entry of successor 0 (0x000011d0)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011cd] debug_log = false
[codex:result] [0x000011d0] analyze_regex, case Append, src = 0x000011d0
[codex:result] [0x000011d0]
               address: 0x000011d0
               instruction: mov edx, [eax + 0x4]
               dhunk:  0: edx<32> := @[(eax<32> + 4<32>),4];
                       1: goto (0x000011d3, 0) 
                      
[codex:result] [0x000011d0] edge from 0 to 1
[codex:result] [0x000011d0] -check- ptr_arith
[1;31m[codex:error] [0x000011d0] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011d0] -check- array_offset_access
[codex:result] [0x000011d0] -check- load_param_nonptr
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0] -check- load_param_nonptr_old
[codex:result] [0x000011d0]
               changes at entry of successor 0 (0x000011d3)
               edx -> {0} or ([1..0xFFFFFFFF] : (char(1))[{0}].0*)

[codex:result] [0x000011d0] debug_log = false
[codex:result] [0x000011d3] analyze_regex, case Append, src = 0x000011d3
[codex:result] [0x000011d3]
               address: 0x000011d3
               instruction: mov eax, [ebp + 0xfffffff8]
               dhunk:  0: eax<32> := @[(ebp<32> + -8<32>),4];
                       1: goto (0x000011d6, 0) 
                      
[codex:result] [0x000011d3] edge from 0 to 1
[codex:result] [0x000011d3] -check- ptr_arith
[codex:result] [0x000011d3] -check- array_offset_access
[codex:result] [0x000011d3]
               changes at entry of successor 0 (0x000011d6)
               eax -> [--..--]

[codex:result] [0x000011d3] debug_log = false
[codex:result] [0x000011ea] analyze_regex, case Append, src = 0x000011ea
[codex:result] [0x000011ea]
               address: 0x000011ea
               instruction: mov eax, [eax]
               dhunk:  0: eax<32> := @[eax<32>,4];
                       1: goto (0x000011ec, 0) 
                      
[codex:result] [0x000011ea] edge from 0 to 1
[codex:result] [0x000011ea] -check- array_offset_access
[1;31m[codex:error] [0x000011ea] -alarm- -alarm- invalid_load_access[0m[0m
[codex:result] [0x000011ea] -check- load_param_nonptr
[codex:result] [0x000011ea] -check- load_param_nonptr_old
[codex:result] [0x000011ea] -check- load_param_nonptr_old
[codex:result] [0x000011ea]
               changes at entry of successor 0 (0x000011ec)
               eax -> {0} or ([1..0xFFFFFFFF] : (Name(struct message))[{0}].0*)

[codex:result] [0x000011ea] debug_log = false
[codex:result] [0x000011ec] analyze_regex, case Append, src = 0x000011ec
[codex:result] [0x000011ec]
               address: 0x000011ec
               instruction: mov [ebp + 0xfffffffc], eax
               dhunk:  0: @[(ebp<32> + -4<32>),4] := eax<32>;
                       1: goto (0x000011ef, 0) 
                      
[codex:result] [0x000011ec] edge from 0 to 1
[codex:result] [0x000011ec] -check- ptr_arith
[codex:result] [0x000011ec] changes at entry of successor 0 (0x000011ef)
                            
[codex:result] [0x000011ec] debug_log = false
[codex:result] [0x000011ef] analyze_regex, case Append, src = 0x000011ef
[codex:result] [0x000011ef]
               address: 0x000011ef
               instruction: mov eax, [ebp + 0xfffffffc]
               dhunk:  0: eax<32> := @[(ebp<32> + -4<32>),4];
                       1: goto (0x000011f2, 0) 
                      
[codex:result] [0x000011ef] edge from 0 to 1
[codex:result] [0x000011ef] -check- ptr_arith
[codex:result] [0x000011ef] -check- array_offset_access
[codex:result] [0x000011ef] changes at entry of successor 0 (0x000011f2)
                            
[codex:result] [0x000011ef] debug_log = false
[codex:result] [0x000011f2] analyze_regex, case Append, src = 0x000011f2
[codex:result] [0x000011f2]
               address: 0x000011f2
               instruction: cmp eax, [ebp + 0xfffffff4]
               dhunk:  0: res32<32> := (eax<32> - @[(ebp<32> + -12<32>),4]);
                       1: OF<1> :=
                           ((eax<32>{31} <> @[(ebp<32> + -9<32>),1]{7}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           (eax<32>{0,3} <u @[(ebp<32> + -12<32>),1]{0,3});
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> := (eax<32> <u @[(ebp<32> + -12<32>),4]);
                       7: goto (0x000011f5, 0) 
                      
[codex:result] [0x000011f2] edge from 0 to 1
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2] -check- ptr_arith
[1;31m[codex:error] [0x000011f2] -alarm- ptr_arith[0m[0m
[codex:result] [0x000011f2] edge from 1 to 2
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:5079)> new <(b:5083)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:5079)> new <(b:5084)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:5088)> new <(b:5092)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:5088)> new <(b:5093)>
[codex:result] [0x000011f2] edge from 2 to 3
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:5097)> new <(b:5101)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:5097)> new <(b:5102)>
[codex:result] [0x000011f2] edge from 3 to 4
[codex:result] [0x000011f2] edge from 4 to 5
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:5112)> new <(b:5116)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:5112)> new <(b:5117)>
[codex:result] [0x000011f2] edge from 5 to 6
[codex:result] [0x000011f2] edge from 6 to 7
[codex:result] [0x000011f2] -check- ptr_arith
[codex:result] [0x000011f2] -check- array_offset_access
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:5141)> new <(b:5145)>
[codex:result] [0x000011f2]
               found boolean by bdd: old <(b:5141)> new <(b:5146)>
[codex:result] [0x000011f2]
               changes at entry of successor 0 (0x000011f5)
               CF -> Bofbool { [--..--] of size 1 }
PF -> Bofbool { [--..--] of size 1 }
AF -> Bofbool { [--..--] of size 1 }
ZF -> Bofbool { [--..--] of size 1 }
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> [--..--]

[codex:result] [0x000011f2] debug_log = false
[codex:result] [0x000011f5] analyze_regex, case Append, src = 0x000011f5
[codex:result] [0x000011f5]
               address: 0x000011f5
               instruction: jnz 0x11c4
               dhunk:  0: if ! (ZF<1>) goto (0x000011c4, 0) else goto 1
                       1: goto (0x000011f7, 0) 
                      
[codex:result] [0x000011f5] edge from 0 to 1
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:5105)> new <(b:5149)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:5105)> new <(b:5150)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:5105)> new <(b:5153)>
[codex:result] [0x000011f5]
               found boolean by bdd: old <(b:5105)> new <(b:5154)>
[codex:result] [0x000011f5] changes at entry of successor 0 (0x000011f7)
                            
[codex:result] [0x000011f5] debug_log = false
[codex:result] [0x000011f5] changes at entry of successor 1 (0x000011c4)
                            
[codex:result] [0x000011f5] debug_log = false
[codex:result] [0x000011f7] analyze_regex, case Append, src = 0x000011f7
[codex:result] [0x000011f7]
               address: 0x000011f7
               instruction: nop
               dhunk:  0: goto (0x000011f8, 0) 
                      
[codex:result] [0x000011f7] changes at entry of successor 0 (0x000011f8)
                            
[codex:result] [0x000011f7] debug_log = false
[codex:result] [0x000011d6] analyze_regex, case Append, src = 0x000011d6
[codex:result] [0x000011d6]
               address: 0x000011d6
               instruction: add eax, edx
               dhunk:  0: res32<32> := (eax<32> + edx<32>);
                       1: OF<1> :=
                           ((eax<32>{31} = edx<32>{31}) &
                            (eax<32>{31} <> res32<32>{31}));
                       2: SF<1> := (res32<32> <s 0<32>);
                       3: ZF<1> := (0<32> = res32<32>);
                       4: AF<1> :=
                           ((extu eax<32>{0,3} 5) + (extu edx<32>{0,3} 5)){4}
                           ;
                       5: PF<1> :=
                           !
                           ((((((((res32<32>{0} ^ res32<32>{1}) ^
                                  res32<32>{2}) ^ res32<32>{3}) ^
                                res32<32>{4}) ^ res32<32>{5}) ^ res32<32>{6})
                             ^ res32<32>{7}));
                       6: CF<1> :=
                           ((extu eax<32> 33) + (extu edx<32> 33)){32};
                       7: eax<32> := res32<32>;
                       8: goto (0x000011d8, 0) 
                      
[codex:result] [0x000011d6] edge from 0 to 1
[codex:result] [0x000011d6] -check- ptr_arith
[1;31m[codex:error] [0x000011d6] -alarm- ptr_arith[0m[0m
[1;33m[codex:warning] [0x000011d6]
                Imprecise offset [--..--] when added. Could be out of bounds[0m[0m
[codex:result] [0x000011d6] edge from 1 to 2
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:5166)> new <(b:5170)>
[codex:result] [0x000011d6]
               found boolean by bdd: old <(b:5166)> new <(b:5171)>
[codex:result] [0x000011d6] edge from 2 to 3
[codex:result] [0x000011d6] edge from 3 to 4
[codex:result] [0x000011d6] edge from 4 to 5
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 5 to 6
[codex:result] [0x000011d6] edge from 6 to 7
[codex:result] [0x000011d6] -check- ptr_arith
[codex:result] [0x000011d6] edge from 7 to 8
[codex:result] [0x000011d6]
               changes at entry of successor 0 (0x000011d8)
               eax -> ([--..--] : (char(1))[{0}].0* + [--..--])
CF -> [--..--]
PF -> Bofbool { [--..--] of size 1 }
AF -> [--..--]
ZF -> {0}
SF -> Bofbool { [--..--] of size 1 }
OF -> [--..--]
res32 -> ([--..--] : (char(1))[{0}].0* + [--..--])

[codex:result] [0x000011d6] debug_log = false
[codex:result] [0x000011f8] analyze_regex, case Append, src = 0x000011f8
[codex:result] [0x000011f8]
               address: 0x000011f8
               instruction: nop
               dhunk:  0: goto (0x000011f9, 0) 
                      
[codex:result] [0x000011f8] changes at entry of successor 0 (0x000011f9)
                            
[codex:result] [0x000011f8] debug_log = false
[codex:result] [0x000011f9] analyze_regex, case Append, src = 0x000011f9
[codex:result] [0x000011f9]
               address: 0x000011f9
               instruction: leave
               dhunk:  0: esp<32> := ebp<32>;
                       1: ebp<32> := @[esp<32>,4];
                       2: esp<32> := (esp<32> + 4<32>);
                       3: goto (0x000011fa, 0) 
                      
[codex:result] [0x000011f9] edge from 0 to 1
[codex:result] [0x000011f9] edge from 1 to 2
[codex:result] [0x000011f9] -check- array_offset_access
[codex:result] [0x000011f9] edge from 2 to 3
[codex:result] [0x000011f9] -check- ptr_arith
[codex:result] [0x000011f9]
               changes at entry of successor 0 (0x000011fa)
               esp -> {0x10000}
ebp -> [--..--]

[codex:result] [0x000011f9] debug_log = false
[codex:result] [0x000011d8] analyze_regex, case Append, src = 0x000011d8
[codex:result] [0x000011d8]
               address: 0x000011d8
               instruction: mov [eax], 0x0
               dhunk:  0: @[eax<32>,1] := 0<8>;
                       1: goto (0x000011db, 0) 
                      
[codex:result] [0x000011d8] edge from 0 to 1
[codex:result] [0x000011d8] -check- store_param_nonptr
[1;31m[codex:error] [0x000011d8] -alarm- store_param_nonptr[0m[0m
[1;31m[codex:error] [0x000011d8]
              No type of size 1 is pointed by pointer (char(1))[{0}].0* + [--..--][0m[0m
[codex:result] [0x000011d8] -check- typing_store
[codex:result] [0x000011d8] changes at entry of successor 0 (0x000011db)
                            
[codex:result] [0x000011d8] debug_log = false
[codex:result] [0x000011fa] analyze_regex, case Append, src = 0x000011fa
[codex:result] [0x000011fa]
               address: 0x000011fa
               instruction: ret
               dhunk:  0: esp<32> := (esp<32> + 4<32>);
                       1: goto @[(esp<32> - 4<32>),4] #return
                      
[codex:result] [0x000011fa] edge from 0 to 1
[codex:result] [0x000011fa] -check- ptr_arith
[codex:result] [0x000011fa] -check- ptr_arith
[codex:result] [0x000011fa] -check- array_offset_access
[codex:result] [0x000011fa] -check- unresolved_dynamic_jump
[codex:result] [0x000011fa]
               changes at entry of successor 0 (0xfedcba98)
               esp -> {0x10004}

[codex:result] [0x000011fa] debug_log = false
[codex:result] [0x000011fa] Analyze end node 0xfedcba98_0x000011fa.
[1;31m[codex:error] [0xfedcba98] Manual skip at 0xfedcba98![0m[0m
[codex:result] [0xfedcba98] Reaching return instruction. Reason: Return hook
[codex:result] [0xfedcba98] Warning: ending path
[codex:result] [0xfedcba98] Fixpoint reached at iteration 1.
[codex:result] [0xfedcba98]
               Over ################################################################
[codex:result] [0xfedcba98] Nodes in the graph (with call stack): 37
[codex:result] [0xfedcba98] Number of instructions (no call stack): 37
[codex:result] [0xfedcba98] End of analyze log
### Alarms ###

== _none_ ==
-alarm count-,-alarm- invalid_load_access,0,1,[0x000011ea]
-alarm count-,ptr_arith,26,4,[0x000011b0 0x000011d0 0x000011d6 0x000011f2]
-alarm count-,store_param_nonptr,1,1,[0x000011d8]


-total alarm count-,6

Analysis time: <dummy>
Total alarms: 6
Preprocessing time : 0.002777s
Analysis time : 0.081995s

